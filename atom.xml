<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>智朋的个人博客</title>
  <icon>https://coffeelize.top/images/cat-avatar.jpg</icon>
  <subtitle>道阻且长，行则将至</subtitle>
  <link href="https://coffeelize.top/atom.xml" rel="self"/>
  
  <link href="https://coffeelize.top/"/>
  <updated>2023-10-15T13:37:13.987Z</updated>
  <id>https://coffeelize.top/</id>
  
  <author>
    <name>coffeelize</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>期刊审稿催稿信</title>
    <link href="https://coffeelize.top/posts/20231015093958.html"/>
    <id>https://coffeelize.top/posts/20231015093958.html</id>
    <published>2023-10-15T01:39:58.000Z</published>
    <updated>2023-10-15T13:37:13.987Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/88821975">审稿时间过长，怎么催？ - 知乎</a></li></ul><span id="more"></span><h3 id="催稿信"><a href="#催稿信" class="headerlink" title="催稿信"></a>催稿信</h3><p>Dear Editor,</p><p>I write concerning the progress of our paper. It was initially submitted on May 13, 2023 and was assigned the manuscript number: xxxx. Now I am worrying about whether it still works normally because the submission has been kept “Under Review” for about two months, as showed on editorial manager. Would you mind checking on the progress of it for me? Your reply would be highly appreciated.</p><p>Thanks very much for your attention to our paper.</p><p>Best Regards.</p><p>Yours sincerely,<br>xxxx</p><h3 id="修订稿催稿信"><a href="#修订稿催稿信" class="headerlink" title="修订稿催稿信"></a>修订稿催稿信</h3><p>Dear Editor,</p><p>I apologize for the inconvenience. I am a graduating master’s student with the intention of pursuing a Ph.D. However, I am concerned about this, as I require another accepted or published paper to strengthen my Ph.D. application. Regarding my revised manuscript with the manuscript number xx-xxxx, which was submitted on xxxx-xx-xx, it is still under review. Could you kindly expedite the review process for my manuscript? I sincerely appreciate your assistance in this matter.</p><p>I look forward to hearing from you soon.</p><p>Best Regards,<br>xxxx</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88821975&quot;&gt;审稿时间过长，怎么催？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LaTeX 修订</title>
    <link href="https://coffeelize.top/posts/20231014163230.html"/>
    <id>https://coffeelize.top/posts/20231014163230.html</id>
    <published>2023-10-14T08:32:30.000Z</published>
    <updated>2023-10-14T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.zhihu.com/question/460475233/answer/2120555503">投了一篇 sci，返回意见是大修，没有经验，请问如何操作？ - 知乎</a></li></ul><span id="more"></span><h3 id="在线编译"><a href="#在线编译" class="headerlink" title="在线编译"></a>在线编译</h3><p>使用 <a href="https://www.overleaf.com/">Overleaf, Online LaTeX Editor</a> 平台</p><ul><li>假设原版本是 <code>Manuscript.tex</code></li><li>新建一个文件 <code>Manuscript-Revised-Cleancopy.tex</code>，并拷贝 <code>Manuscript.tex</code> 中的所有内容，在这个新建的文件上进行修改，编写修订后的终稿</li><li>新建一个文件叫做 <code>Manuscript-Diff-Withtrack.tex</code>, 内容如下：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\RequirePackage{shellesc}</span><br><span class="line">\ShellEscape{latexdiff Manuscript.tex Manuscript-Revised-Cleancopy.tex &gt; Manuscript-Diff-Withtrack.tex}</span><br><span class="line">\input{Manuscript-Diff-Withtrack}</span><br><span class="line">\documentclass{dummy}</span><br></pre></td></tr></tbody></table></figure><ul><li>如需生成旧版本，打开 Manuscript.tex 后点击 Recompile</li><li> 如需生成新版本，打开 Manuscript-Revised-Cleancopy.tex 后点击 Recompile</li><li> 如需生成变化追踪的版本，打开 Manuscript-Diff-Withtrack.tex 后点击 Recompile</li></ul><p>参考资料：<a href="https://www.zhihu.com/question/460475233/answer/2120555503">投了一篇 sci，返回意见是大修，没有经验，请问如何操作？ - 知乎</a></p><h3 id="本地编译"><a href="#本地编译" class="headerlink" title="本地编译"></a>本地编译</h3><p>初稿 LaTeX，并且已经写好 LaTeX 的终稿 —&gt; 导入 <a href="https://3142.nl/latex-diff/">Online LaTeX diff tool</a> 中生成<strong>带有修订的 LaTeX 稿件</strong> —&gt; 使用本地 LaTeX 编译器进行编译生成 PDF</p><h4 id="Online-LaTeX-diff-tool"><a href="#Online-LaTeX-diff-tool" class="headerlink" title="Online LaTeX diff tool"></a>Online LaTeX diff tool</h4><p>在线工具： <a href="https://3142.nl/latex-diff/">Online LaTeX diff tool</a></p><ul><li> 输入：两个版本的 LaTeX 原稿文件</li><li>输出：带有修订标记的单个 LaTeX 源文件</li><li>参考示例：</li></ul><p><img data-src="https://s2.loli.net/2023/10/14/iLGXrd25cBpVosN.png" alt="image.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/460475233/answer/2120555503&quot;&gt;投了一篇 sci，返回意见是大修，没有经验，请问如何操作？ - 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LaTeX" scheme="https://coffeelize.top/categories/LaTeX/"/>
    
    
  </entry>
  
  <entry>
    <title>经验分享</title>
    <link href="https://coffeelize.top/posts/20231014150502.html"/>
    <id>https://coffeelize.top/posts/20231014150502.html</id>
    <published>2023-10-14T07:05:02.000Z</published>
    <updated>2023-10-15T03:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="谷歌学术"><a href="#谷歌学术" class="headerlink" title="谷歌学术"></a>谷歌学术</h3><ul><li>站在巨人的肩膀上 &amp; 纯粹的学术网站</li><li>摘要甚至全文检索 —&gt; No.1</li><li> 邮件订阅领域作者 —&gt; 获取作者 / 文献引用最新进展</li><li> BibTeX 引用文献导出 —&gt; LaTeX 参考文献数据库</li></ul><span id="more"></span><p>检索词对比：<a href="https://www.cnki.net/#/">知网</a> | <a href="https://scholar.google.com.hk/?hl=zh-CN">Google 学术搜索</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Photovoltaic module recycling</span><br><span class="line">End-of-life</span><br><span class="line">Silicon PV modules</span><br><span class="line">Physical Recovery</span><br><span class="line">Low temperatures</span><br><span class="line">Aluminum back field</span><br></pre></td></tr></tbody></table></figure><h3 id="谷歌专利"><a href="#谷歌专利" class="headerlink" title="谷歌专利"></a>谷歌专利</h3><ul><li>Search and read the full text of patents from around the world</li><li> 专利免费下载，PDF 格式</li><li>数据统计功能 </li></ul><p><img data-src="https://s2.loli.net/2023/10/14/5jBZ9fhWi4XyYkR.png" alt="image.png"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">泡沫玻璃 制备</span><br><span class="line">光伏组件回收</span><br></pre></td></tr></tbody></table></figure><h3 id="文献管理"><a href="#文献管理" class="headerlink" title="文献管理"></a>文献管理</h3><p>Zotero：<a href="https://www.zotero.org/">Zotero | Your personal research assistant</a></p><ul><li> 开源 —&gt; 免费</li><li>流畅 —&gt; 不卡顿</li><li>可通过 Webdev 多端同步 —&gt; 可配置第三方云同步</li><li> Word 插件 —&gt; 插入文献</li><li>浏览器插件 —&gt; 导入文献</li><li>软件插件 —&gt; 丰富功能</li><li>参考资料：<a href="https://coffeelize.top/posts/a6f9f7b7.html">Zotero 学习笔记 | 智朋的个人博客</a></li><li>拓展资料：<a href="https://zotero-chinese.com/">Zotero 中文小组 | Zotero 中文小组</a></li></ul><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><h4 id="Figma-Sketch"><a href="#Figma-Sketch" class="headerlink" title="Figma / Sketch"></a>Figma / Sketch</h4><ul><li>定位：专业的前端美工绘图工具</li><li>矢量绘图 —&gt; 高清晰度示意图</li><li>图层管理 —&gt; 复杂绘图</li><li>插件丰富 —&gt; 丰富功能</li><li>参考资料：<a href="https://coffeelize.top/posts/82ded38b.html">sketch 绘图指南 | 智朋的个人博客</a></li></ul><h4 id="Visio"><a href="#Visio" class="headerlink" title="Visio"></a>Visio</h4><ul><li>排版布局组图方便</li><li>修改方便</li><li>微软套件，嵌入方便</li><li>参考资料：<a href="https://coffeelize.top/posts/659137c6.html">Visio 学习笔记 | 智朋的个人博客</a></li></ul><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3><ul><li>参考资料：<a href="https://coffeelize.top/posts/a9e583b4.html">LaTeX 相关资源汇总 | 智朋的个人博客</a></li></ul><h3 id="拓展资料"><a href="#拓展资料" class="headerlink" title="拓展资料"></a>拓展资料</h3><ul><li>Github：<a href="https://github.com/pengsida/learning_research">GitHub - pengsida/learning_research: 本人的科研经验</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;谷歌学术&quot;&gt;&lt;a href=&quot;#谷歌学术&quot; class=&quot;headerlink&quot; title=&quot;谷歌学术&quot;&gt;&lt;/a&gt;谷歌学术&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;站在巨人的肩膀上 &amp;amp; 纯粹的学术网站&lt;/li&gt;
&lt;li&gt;摘要甚至全文检索 —&amp;gt; No.1&lt;/li&gt;
&lt;li&gt; 邮件订阅领域作者 —&amp;gt; 获取作者 / 文献引用最新进展&lt;/li&gt;
&lt;li&gt; BibTeX 引用文献导出 —&amp;gt; LaTeX 参考文献数据库&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Research" scheme="https://coffeelize.top/categories/Research/"/>
    
    
    <category term="Research" scheme="https://coffeelize.top/tags/Research/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian2Anki</title>
    <link href="https://coffeelize.top/posts/20230809163600.html"/>
    <id>https://coffeelize.top/posts/20230809163600.html</id>
    <published>2023-08-09T08:36:00.000Z</published>
    <updated>2023-08-09T08:39:38.732Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://github.com/Pseudonium/Obsidian_to_Anki">GitHub - Pseudonium/Obsidian_to_Anki: Script to add flashcards from text/markdown files to Anki</a></li><li><a href="https://www.bilibili.com/video/BV1i5411P7wc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=3ae7ae95fa254383ab9ae83f75abd29d">快速制作 anki 卡片 | 笔记神器 Obsidian 完全指南_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/read/cv10387577">用 Obisidian 制作 Anki 里面用的代码 - 哔哩哔哩</a></li><li><a href="https://www.youtube.com/watch?v=PXyv6pnVGhA">How To Sync Obsidian With Anki Automatically / Plugin Walkthrough - YouTube</a></li></ul><span id="more"></span><iframe width="560" height="315" src="https://www.youtube.com/embed/PXyv6pnVGhA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe><h3 id="Obsidian-to-Anki-插件教程"><a href="#Obsidian-to-Anki-插件教程" class="headerlink" title="Obsidian_to_Anki 插件教程"></a>Obsidian_to_Anki 插件教程</h3><h4 id="Anki-插件设置"><a href="#Anki-插件设置" class="headerlink" title="Anki 插件设置"></a>Anki 插件设置</h4><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    "apiKey": null,</span><br><span class="line">    "apiLogPath": null,</span><br><span class="line">    "webBindAddress": "127.0.0.1",</span><br><span class="line">    "webBindPort": 8765,</span><br><span class="line">    "webCorsOrigin": "http://localhost",</span><br><span class="line">    "webCorsOriginList": [</span><br><span class="line">        "http://localhost",</span><br><span class="line"><span class="addition">+       "app://obsidian.md"</span></span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改完之后如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    "apiKey": null,</span><br><span class="line">    "apiLogPath": null,</span><br><span class="line">    "webBindAddress": "127.0.0.1",</span><br><span class="line">    "webBindPort": 8765,</span><br><span class="line">    "webCorsOrigin": "http://localhost",</span><br><span class="line">    "webCorsOriginList": [</span><br><span class="line">        "http://localhost",</span><br><span class="line">        "app://obsidian.md"</span><br><span class="line">    ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Ob-笔记设置"><a href="#Ob-笔记设置" class="headerlink" title="Ob 笔记设置"></a>Ob 笔记设置</h4><p>笔记开头声明牌组：<code>TARGET DECK: Test</code></p><ul><li>Test 表示对应 Anki 中的目标牌组名</li><li>卡片笔记的书写格式请参考：<a href="https://github.com/Pseudonium/Obsidian_to_Anki/wiki/Neuracache-flashcard-style">Neuracache flashcard style · Pseudonium/Obsidian_to_Anki Wiki · GitHub</a>，或者继续阅读下文</li></ul><h3 id="普通卡-Neuracache"><a href="#普通卡-Neuracache" class="headerlink" title="普通卡 Neuracache"></a>普通卡 Neuracache</h3><p>正则表达式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((?:[^\n][\n]?)+)&nbsp;#flashcard&nbsp;?\n*((?:\n(?:^.{1,3}$|^.{4}(?&lt;!&lt;!--).*))+)</span><br></pre></td></tr></tbody></table></figure><p>参考资料：<a href="https://github.com/Pseudonium/Obsidian_to_Anki/wiki/Neuracache-flashcard-style">Neuracache flashcard style · Pseudonium/Obsidian_to_Anki Wiki · GitHub</a></p><p>卡片语法示例</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TARGET DECK: Test</span><br><span class="line"></span><br><span class="line">卡片正面内容&nbsp;#flashcard</span><br><span class="line">卡片背面内容</span><br></pre></td></tr></tbody></table></figure><p>如下，若添加进 Anki 成功的话，会自动在卡片的下方添加上一个 html 注释</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TARGET DECK: Test</span><br><span class="line"></span><br><span class="line">卡片正面内容&nbsp;#flashcard</span><br><span class="line">卡片背面内容</span><br><span class="line">&lt;!--ID: 1691487007086--&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果想要清除 Anki 中的卡片，在 ID 上一行添加 <code>DELETE</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是卡片正面 #flashcard</span><br><span class="line">this is the back of the card</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>DELETE 需要大写，同步之后，Anki 中对应的卡片就被自动删除了，Ob 中的笔记还在，只是将这条笔记下方的 ID 被删除了（也就是说下次同步时，还会自动往 Anki 中添加这条笔记）</li><li>如果 Anki 中删除了笔记，而 Ob 中没有删除的话，那么同步 Ob 时，也不会往 Anki 中添加卡片了，因为这条笔记下面的 ID 还没有被删除</li></ul><h3 id="挖空卡-Cloze"><a href="#挖空卡-Cloze" class="headerlink" title="挖空卡 Cloze"></a>挖空卡 Cloze</h3><p>正则表达式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((?:.+\n)*(?:.*{.*)(?:\n(?:^.{1,3}$|^.{4}(?&lt;!&lt;!--).*))*)</span><br></pre></td></tr></tbody></table></figure><p>参考资料：<a href="https://github.com/Pseudonium/Obsidian_to_Anki/wiki/Cloze-Paragraph-style">Cloze Paragraph style · Pseudonium/Obsidian_to_Anki Wiki · GitHub</a></p><p>注意：将正则表达式粘贴到 Cloze 类型的模板当中</p><h3 id="高亮挖空卡"><a href="#高亮挖空卡" class="headerlink" title="高亮挖空卡"></a>高亮挖空卡</h3><p>正则表达式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((?:.+\n)*(?:.*==.*)(?:\n(?:^.{1,3}$|^.{4}(?&lt;!&lt;!--).*))*)</span><br></pre></td></tr></tbody></table></figure><p>参考资料：<a href="https://github.com/Pseudonium/Obsidian_to_Anki/wiki/Cloze-Paragraph-style">Cloze Paragraph style · Pseudonium/Obsidian_to_Anki Wiki · GitHub</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is the ==highlight== note</span><br></pre></td></tr></tbody></table></figure><p>注意：如果是需要开启 Highlight-cloze style，那么需要同时打开 CurlyCloze 和 CurlyCloze - Highlights to Cloze 两关开关</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Pseudonium/Obsidian_to_Anki&quot;&gt;GitHub - Pseudonium/Obsidian_to_Anki: Script to add flashcards from text/markdown files to Anki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1i5411P7wc/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=3ae7ae95fa254383ab9ae83f75abd29d&quot;&gt;快速制作 anki 卡片 | 笔记神器 Obsidian 完全指南_哔哩哔哩_bilibili&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/read/cv10387577&quot;&gt;用 Obisidian 制作 Anki 里面用的代码 - 哔哩哔哩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=PXyv6pnVGhA&quot;&gt;How To Sync Obsidian With Anki Automatically / Plugin Walkthrough - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Anki" scheme="https://coffeelize.top/categories/Anki/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 LaTeX 制作 Lyric</title>
    <link href="https://coffeelize.top/posts/20230806214851.html"/>
    <id>https://coffeelize.top/posts/20230806214851.html</id>
    <published>2023-08-06T13:48:51.000Z</published>
    <updated>2023-08-06T15:21:49.868Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>输出一份 PDF 文件，左侧为英文歌词，右侧为中文歌词翻译，尽量保持排版美观。文末附中英文歌词</p><span id="more"></span><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>代码中较难理解的部分已添加注释</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[12pt]{ctexart}</span><br><span class="line">\usepackage{geometry}</span><br><span class="line">\usepackage{multicol}</span><br><span class="line">\usepackage{fontspec}</span><br><span class="line">\usepackage{eso-pic}</span><br><span class="line">\usepackage{tikz}</span><br><span class="line">\usepackage{paracol}</span><br><span class="line">\usepackage{fancyhdr}</span><br><span class="line">\usepackage{hyperref}</span><br><span class="line"></span><br><span class="line">% 设置页面大小和边距</span><br><span class="line">\geometry{a4paper,left=1.5cm,right=1.5cm,top=2cm,bottom=2cm}</span><br><span class="line"></span><br><span class="line">% 设置背景为网格</span><br><span class="line">\AddToShipoutPictureBG{%</span><br><span class="line">\begin{tikzpicture}[overlay,remember picture]</span><br><span class="line">\draw[step=5mm, color=gray!10, line width=0.2mm] (current page.south west) grid (current page.north east);</span><br><span class="line">\end{tikzpicture}%</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">% 设置页眉和页脚样式</span><br><span class="line">\pagestyle{fancy}</span><br><span class="line">\fancyhf{}</span><br><span class="line">\renewcommand{\headrulewidth}{0pt}</span><br><span class="line">\cfoot{\thepage}</span><br><span class="line">\rfoot{\href{https://coffeelize.top/}{Design By Coffeelize}}</span><br><span class="line"></span><br><span class="line">% 设置字体</span><br><span class="line">\setmainfont{Times New Roman}</span><br><span class="line">\newfontfamily\zhfont{Source Han Serif CN}</span><br><span class="line"></span><br><span class="line">% 取消段落首行缩进</span><br><span class="line">\setlength{\parindent}{0pt}</span><br><span class="line"></span><br><span class="line">% 设置列间距和列宽比例</span><br><span class="line">\setlength{\columnsep}{0.5cm}</span><br><span class="line">\columnratio{0.6}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line"></span><br><span class="line">\section*{The Wandering Star}</span><br><span class="line"></span><br><span class="line">\hspace{1em}</span><br><span class="line"></span><br><span class="line">\begin{paracol}{2}</span><br><span class="line"></span><br><span class="line">\begin{leftcolumn*}</span><br><span class="line">Soothsayer's lured to her star \\</span><br><span class="line">Server of heaven's silent wanderers \\</span><br><span class="line">Oh holy night, summon up the ghost \\</span><br><span class="line">The hard of hearing always listen closest \\</span><br><span class="line">The hard of hearing always listen closest</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">Lo lo lo lo lo, lo lo and behold \\</span><br><span class="line">It has been foretold lo lo lo lo long ago \\</span><br><span class="line">Lo lo lo lo lo, lo lo and behold \\</span><br><span class="line">I guess you never know what you never know</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">Saturn, Jupiter confer, breaker of the wall in the morning \\</span><br><span class="line">Aries, Pisces, either one \\</span><br><span class="line">You will never know firsthand what day you're born on</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">Lo lo lo lo lo, lo lo and behold \\</span><br><span class="line">It has been foretold lo lo lo lo long ago \\</span><br><span class="line">Lo lo lo lo lo, lo lo and behold \\</span><br><span class="line">I guess you never know what you never know</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">Wandering star\\</span><br><span class="line">Wandering star\\</span><br><span class="line">Wandering star\\</span><br><span class="line">Wandering star</span><br><span class="line"></span><br><span class="line">\end{leftcolumn*}</span><br><span class="line"></span><br><span class="line">\switchcolumn</span><br><span class="line"></span><br><span class="line">% 右侧中文</span><br><span class="line">\zhfont</span><br><span class="line"></span><br><span class="line">被诱至她的星辰的预言家\\</span><br><span class="line">天堂的寂静漫游者的仆人\\</span><br><span class="line">哦，神圣的夜晚，召唤幽灵\\</span><br><span class="line">听力不佳的人总是最专注地倾听\\</span><br><span class="line">听力不佳的人总是最专注地倾听</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">啦啦啦啦啦，啦啦看哪\\</span><br><span class="line">这早已被预言啦啦啦啦很久以前\\</span><br><span class="line">啦啦啦啦啦，啦啦看哪\\</span><br><span class="line">我猜你永远不会知道你从未知道的事情</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">土星，木星交谈，清晨的墙壁破碎者\\</span><br><span class="line">白羊座，双鱼座，任何一个\\</span><br><span class="line">你永远不会亲自知道你是在哪一天出生的</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">啦啦啦啦啦，啦啦看哪\\</span><br><span class="line">这早已被预言啦啦啦啦很久以前\\</span><br><span class="line">啦啦啦啦啦，啦啦看哪\\</span><br><span class="line">我猜你永远不会知道你从未知道的事情</span><br><span class="line"></span><br><span class="line">\hspace{2em}</span><br><span class="line"></span><br><span class="line">漫游的星星\\</span><br><span class="line">漫游的星星\\</span><br><span class="line">漫游的星星\\</span><br><span class="line">漫游的星星</span><br><span class="line"></span><br><span class="line">\end{paracol}</span><br><span class="line"></span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/08/06/aEWCuO97MnrdlAi.png" alt="image.png"></p><p>注：中文翻译来源于 GPT 翻译</p><h2 id="The-Wandering-Star-中英文歌词"><a href="#The-Wandering-Star-中英文歌词" class="headerlink" title="The Wandering Star 中英文歌词"></a>The Wandering Star 中英文歌词</h2><p>这里提供 The Wandering Star 中英文歌词，如果大家有更好的排版方案，可以使用如下的歌词进行排版</p><hr><p>Soothsayer’s lured to her star<br>Server of heaven’s silent wanderers<br>Oh holy night, summon up the ghost<br>The hard of hearing always listen closest<br>The hard of hearing always listen closest</p><p>Lo lo lo lo lo, lo lo and behold<br>It has been foretold lo lo lo lo long ago<br>Lo lo lo lo lo, lo lo and behold<br>I guess you never know what you never know</p><p>Saturn, Jupiter confer, breaker of the wall in the morning<br>Aries, Pisces, either one<br>You will never know firsthand what day you’re born on</p><p>Lo lo lo lo lo, lo lo and behold<br>It has been foretold lo lo lo lo long ago<br>Lo lo lo lo lo, lo lo and behold<br>I guess you never know what you never know</p><p>Wandering star<br>Wandering star<br>Wandering star<br>Wandering star</p><hr><p>被诱至她的星辰的预言家<br>天堂的寂静漫游者的仆人<br>哦，神圣的夜晚，召唤幽灵<br>听力不佳的人总是最专注地倾听<br>听力不佳的人总是最专注地倾听</p><p>啦啦啦啦啦，啦啦看哪<br>这早已被预言啦啦啦啦很久以前<br>啦啦啦啦啦，啦啦看哪<br>我猜你永远不会知道你从未知道的事情</p><p>土星，木星交谈，清晨的墙壁破碎者<br>白羊座，双鱼座，任何一个<br>你永远不会亲自知道你是在哪一天出生的</p><p>啦啦啦啦啦，啦啦看哪<br>这早已被预言啦啦啦啦很久以前<br>啦啦啦啦啦，啦啦看哪<br>我猜你永远不会知道你从未知道的事情</p><p>漫游的星星<br>漫游的星星<br>漫游的星星<br>漫游的星星</p><h2 id="有用的资料"><a href="#有用的资料" class="headerlink" title="有用的资料"></a>有用的资料</h2><p>在线 LaTeX 格式化工具：<a href="https://c.albert-thompson.com/latex-pretty/">Online Latex Formatter</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;输出一份 PDF 文件，左侧为英文歌词，右侧为中文歌词翻译，尽量保持排版美观。文末附中英文歌词&lt;/p&gt;</summary>
    
    
    
    <category term="LaTeX" scheme="https://coffeelize.top/categories/LaTeX/"/>
    
    
  </entry>
  
  <entry>
    <title>Obsidian2Hexo</title>
    <link href="https://coffeelize.top/posts/20230802213829.html"/>
    <id>https://coffeelize.top/posts/20230802213829.html</id>
    <published>2023-08-02T13:38:29.000Z</published>
    <updated>2023-10-15T13:18:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="最终流程图"><a href="#最终流程图" class="headerlink" title="最终流程图"></a>最终流程图</h2><ul><li>简明流程：Win (obsidian) &lt;— 坚果云 —&gt; Mac (obsidian) &lt;— 软链接 —&gt; Hexo</li><li> 实现功能：Win 的 Obsidian 做笔记，或者 Mac 的 Obsidian 做笔记 —&gt; md 格式的文件 —&gt; 通过 hexo 的 3 条命令上传至博客</li></ul><p><img data-src="https://s2.loli.net/2023/10/15/utePdQFq2JiV9o1.png" alt="image.png"></p><h2 id="Why-Obsidian"><a href="#Why-Obsidian" class="headerlink" title="Why Obsidian"></a>Why Obsidian</h2><p>博客文章都是使用 Markdown 格式完成的，在 Markdown 编辑体验上，Obsidian 的体验要远远好于 VS Code。毕竟术业有专攻，Obsidian 主打 Markdown 这种垂直领域的文件编辑，而 VS Code 作为通用代码编辑器，不奢求太多体验，大抵能用就行</p><p>Obsidian 丰富的插件、轻量和自定义程度高的快捷键这几点已经足以秒杀大多数具有 Markdown 编辑功能的编辑器了</p><span id="more"></span><h2 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h2><h3 id="Yaml-字段问题"><a href="#Yaml-字段问题" class="headerlink" title="Yaml 字段问题"></a>Yaml 字段问题</h3><p>Hexo 的 URL 使用 abbrlink 永久链接，而这个永久链接是使用 CRC32 算法和十六进制表示法生成的，在 Ob 中自然没有现成的工具可以实现这个功能 —&gt; 那么转换思路，abbrlink 只要唯一就好，完全可以使用时间戳来代替这种复杂的计算</p><p>至于时间戳，可以使用 Ob 核心插件中的 <code>模板</code> 插件来完成，创建文件后即可自动添加 abbrlink</p><p><img data-src="https://s2.loli.net/2023/08/03/ngPDfHIOuK3ANVi.png" alt="image.png"></p><p>同理，date 和 title 字段也可以使用模板来完成，简易的 YAML 字段如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: {{NAME}}</span><br><span class="line">categories: </span><br><span class="line">date: {{DATE:YYYY-MM-DD HH:mm:ss}}</span><br><span class="line">abbrlink: {{DATE:YYYYMMDDHHmmss}}</span><br><span class="line">tag: </span><br></pre></td></tr></tbody></table></figure><h3 id="图片上传问题"><a href="#图片上传问题" class="headerlink" title="图片上传问题"></a>图片上传问题</h3><p>习惯使用 SM.MS 这类的图床工具，在 Ob 中插入图片还需要额外手动将文中图片一张张上传到图床中，过程简单但又浪费时间，操作过程也毫无意义 —&gt; 需要一个更加自动化的流程</p><p>既然锁定了图床这类工具，必然和 image 有关，思路也很清晰，去 Ob 的插件市场搜索关键词 image 即可</p><p><img data-src="https://s2.loli.net/2023/08/03/KCagtsEyUh4v5HB.png" alt="image.png"></p><p>参考资料：</p><ul><li>Obsidian 插件：<a href="https://github.com/renmu123/obsidian-image-auto-upload-plugin">GitHub - renmu123/obsidian-image-auto-upload-plugin: auto upload image with picgo</a></li><li>Picgo：<a href="https://github.com/Molunerfinn/PicGo">GitHub - Molunerfinn/PicGo: :rocket:A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder</a></li><li>Picgo 安装使用过程中易出现的问题（如 macOS 系统安装完 PicGo 显示「文件已损坏」或者安装完打开没有反应）：<a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md">FAQ.md</a></li></ul><h3 id="图片压缩问题"><a href="#图片压缩问题" class="headerlink" title="图片压缩问题"></a>图片压缩问题</h3><p>问题也很清晰，在 <a href="https://coffeelize.top/posts/5566e923.html?highlight=%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9">图片压缩指南 | 智朋的个人博客</a> 中已经介绍过了几款工具，推荐使用 <a href="https://saerasoft.com/caesium">caesium</a>，可这仍然无法接入自动化流程 —&gt; 需要将图片上传至图床前自动压缩图片 —&gt; 也就指向了 Picgo 上传工具</p><p><img data-src="https://s2.loli.net/2023/08/03/WptmEhIBArL6cFw.png" alt="image.png"></p><p><img data-src="https://s2.loli.net/2023/08/03/TZWfD1hxiSItMUj.png" alt="image.png"></p><p>注：图床配置名是根据 <code>图床设置</code> 自己设置的，并非一定为 “SM”</p><p>参考资料：<a href="https://github.com/JuZiSang/picgo-plugin-compress">GitHub - juzisang/picgo-plugin-compress: Image compression plugin for PicGo</a></p><p>经测试，同样一张截图，系统直接保存图片 127KB，通过插件压缩上传后 39KB，压缩效果可以，主要是实现了自动化</p><p>实际上，对于非博客中的文章，如自己的一些笔记，当然还是插入本地图片更方便。插件作者在设计上增加了一个控制开关，在 MD 文件的 YAML 区添加 <code>image-auto-upload: true</code> 才实现图片粘贴上传功能 —&gt; 因此，可以利用 QuickAdd + 模板 (配置好 YAML 区) 来实现「只有某一种模板的文件，向其中粘贴图片的时候才会自动上传到图床中」</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: {{NAME}}</span><br><span class="line">categories: </span><br><span class="line">date: {{DATE:YYYY-MM-DD HH:mm:ss}}</span><br><span class="line">abbrlink: {{DATE:YYYYMMDDHHmmss}}</span><br><span class="line">image-auto-upload: true</span><br><span class="line">tag: </span><br></pre></td></tr></tbody></table></figure><h3 id="文件同步问题"><a href="#文件同步问题" class="headerlink" title="文件同步问题"></a>文件同步问题</h3><p>面临的问题：Ob 资源文件夹路径和 hexo 文件夹路径不在一块，如何将 hexo 中包含 markdown 文件的文件夹导入到 Ob 资源库中是一个问题</p><h4 id="尝试-1：使用-rsync-命令工具"><a href="#尝试-1：使用-rsync-命令工具" class="headerlink" title="尝试 1：使用 rsync 命令工具"></a>尝试 1：使用 rsync 命令工具</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avzh --delete /Users/wuzhipeng/Documents/ZhPObsidian/ZhPObsidian/_posts  /Users/wuzhipeng/ZhPblog/source</span><br></pre></td></tr></tbody></table></figure><p>选项说明</p><ul><li><code>-a</code>&nbsp;或&nbsp;<code>--archive</code>：以归档模式同步文件，包括保留文件权限、时间戳等元数据。</li><li><code>-v</code>&nbsp;或&nbsp;<code>--verbose</code>：显示详细的输出信息。</li><li><code>-z</code>&nbsp;或&nbsp;<code>--compress</code>：使用压缩传输来减少数据传输量。</li><li><code>-h</code>&nbsp;或&nbsp;<code>--human-readable</code>：以易读的格式显示输出信息。</li><li><code>-n</code>&nbsp;或&nbsp;<code>--dry-run</code>：模拟同步操作，不实际同步文件。</li><li><code>-P</code>&nbsp;或&nbsp;<code>--progress</code>：显示同步进度。</li><li><code>--delete</code>：在目标目录中删除不存在于源文件夹中的文件。</li><li><code>--exclude</code>：排除指定的文件或目录。</li><li><code>--include</code>：只包含指定的文件或目录。</li><li><code>--bwlimit</code>：限制带宽使用。</li></ul><p>的确可以同步，但这样做有几个明显的缺点：</p><ul><li>单向同步：如果双方都做了修改，那么需要左右来回同步一次，容易出错</li><li>同步错误：虽然同步是成功的，但是有报错的出现且暂时无法解决，用起来不放心 </li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync error: some files could not be transferred (code 23) at /AppleInternal/Library/BuildRoots/c2cb9645-dafc-11ed-aa26-6ec1e3b3f7b3/Library/Caches/com.apple.xbs/Sources/rsync/rsync/main.c(996)</span><br></pre></td></tr></tbody></table></figure><h4 id="尝试-2：软链接"><a href="#尝试-2：软链接" class="headerlink" title="尝试 2：软链接"></a>尝试 2：软链接</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /Users/wuzhipeng/Documents/ZhPObsidian/ZhPObsidian/_posts  /Users/wuzhipeng/ZhPblog/source</span><br></pre></td></tr></tbody></table></figure><p>没想到 Ob 支持软链接，这样 hexo 和 Obsidian 访问的就是同一文件目录，不涉及同步问题，这样也很稳定，目前使用的就是这种方案</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最终流程图&quot;&gt;&lt;a href=&quot;#最终流程图&quot; class=&quot;headerlink&quot; title=&quot;最终流程图&quot;&gt;&lt;/a&gt;最终流程图&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简明流程：Win (obsidian) &amp;lt;— 坚果云 —&amp;gt; Mac (obsidian) &amp;lt;— 软链接 —&amp;gt; Hexo&lt;/li&gt;
&lt;li&gt; 实现功能：Win 的 Obsidian 做笔记，或者 Mac 的 Obsidian 做笔记 —&amp;gt; md 格式的文件 —&amp;gt; 通过 hexo 的 3 条命令上传至博客&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img data-src=&quot;https://s2.loli.net/2023/10/15/utePdQFq2JiV9o1.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Why-Obsidian&quot;&gt;&lt;a href=&quot;#Why-Obsidian&quot; class=&quot;headerlink&quot; title=&quot;Why Obsidian&quot;&gt;&lt;/a&gt;Why Obsidian&lt;/h2&gt;&lt;p&gt;博客文章都是使用 Markdown 格式完成的，在 Markdown 编辑体验上，Obsidian 的体验要远远好于 VS Code。毕竟术业有专攻，Obsidian 主打 Markdown 这种垂直领域的文件编辑，而 VS Code 作为通用代码编辑器，不奢求太多体验，大抵能用就行&lt;/p&gt;
&lt;p&gt;Obsidian 丰富的插件、轻量和自定义程度高的快捷键这几点已经足以秒杀大多数具有 Markdown 编辑功能的编辑器了&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://coffeelize.top/categories/Hexo/"/>
    
    
    <category term="Markdown" scheme="https://coffeelize.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX 多图排版</title>
    <link href="https://coffeelize.top/posts/809da89d.html"/>
    <id>https://coffeelize.top/posts/809da89d.html</id>
    <published>2023-05-18T00:35:57.000Z</published>
    <updated>2023-05-18T00:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="图片排版"><a href="#图片排版" class="headerlink" title="图片排版"></a>图片排版</h3><ul><li>搭配 <a href="https://coffeelize.top/posts/9165505d.html">coffeelize.sty</a> 宏包使用</li><li>使用 subfigure 宏包</li></ul><span id="more"></span><h4 id="两图并排"><a href="#两图并排" class="headerlink" title="两图并排"></a>两图并排</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{ctexart}</span><br><span class="line">\usepackage{coffeelize}</span><br><span class="line">\usepackage{graphicx}</span><br><span class="line">\usepackage{subfigure}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line"></span><br><span class="line">\begin{figure}[htbp]</span><br><span class="line"> \centering</span><br><span class="line"> \subfigure[subfig:1]{</span><br><span class="line">  \includegraphics[width=0.48\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \subfigure[subfig:2]{</span><br><span class="line">  \includegraphics[width=0.48\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \caption{两张图片并列}</span><br><span class="line"> \label{fig:subfigure_example1}</span><br><span class="line">\end{figure}</span><br><span class="line"> </span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/05/18/Sp3heqlWH25wGia.png" alt="01-两图并排.png"></p><h4 id="三图并排"><a href="#三图并排" class="headerlink" title="三图并排"></a>三图并排</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{ctexart}</span><br><span class="line">\usepackage{coffeelize}</span><br><span class="line">\usepackage{graphicx}</span><br><span class="line">\usepackage{subfigure}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line"></span><br><span class="line">\begin{figure}[htbp]</span><br><span class="line"> \centering</span><br><span class="line"> \subfigure[subfig:1]{</span><br><span class="line">  \includegraphics[width=0.3\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \subfigure[subfig:2]{</span><br><span class="line">  \includegraphics[width=0.3\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \subfigure[subfig:3]{</span><br><span class="line"> \includegraphics[width=0.3\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \caption{两张图片并列}</span><br><span class="line"> \label{fig:subfigure_example1}</span><br><span class="line">\end{figure}</span><br><span class="line"> </span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/05/18/KtFlv43dJy2Ppui.png" alt="02-三图并排.png"></p><h4 id="四图并排"><a href="#四图并排" class="headerlink" title="四图并排"></a>四图并排</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{ctexart}</span><br><span class="line">\usepackage{coffeelize}</span><br><span class="line">\usepackage{graphicx}</span><br><span class="line">\usepackage{subfigure}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line"></span><br><span class="line">\begin{figure}[htbp]</span><br><span class="line"> \centering</span><br><span class="line"> \subfigure[subfig:1]{</span><br><span class="line">  \includegraphics[width=0.2\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \subfigure[subfig:2]{</span><br><span class="line">  \includegraphics[width=0.2\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \subfigure[subfig:3]{</span><br><span class="line"> \includegraphics[width=0.2\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \subfigure[subfig:4]{</span><br><span class="line"> \includegraphics[width=0.2\textwidth]{example-image-A}</span><br><span class="line"> }</span><br><span class="line"> \caption{两张图片并列}</span><br><span class="line"> \label{fig:subfigure_example1}</span><br><span class="line">\end{figure}</span><br><span class="line"> </span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/05/18/a5zSktW8C19GbYJ.png" alt="03-四图并排.png"></p><h4 id="两行四图并排"><a href="#两行四图并排" class="headerlink" title="两行四图并排"></a>两行四图并排</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{ctexart}</span><br><span class="line">\usepackage{coffeelize}</span><br><span class="line">\usepackage{graphicx}</span><br><span class="line">\usepackage{subfigure}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line"></span><br><span class="line">\begin{figure}[htbp]</span><br><span class="line"> \centering</span><br><span class="line"> \subfigure[图1]{\includegraphics[width=0.48\linewidth]{example-image-A}}\quad</span><br><span class="line"> \subfigure[图2]{\includegraphics[width=0.48\linewidth]{example-image-A}}</span><br><span class="line"> \\</span><br><span class="line"> \subfigure[图3]{\includegraphics[width=0.48\linewidth]{example-image-A}}\quad</span><br><span class="line"> \subfigure[图4]{\includegraphics[width=0.48\linewidth]{example-image-A}}</span><br><span class="line"> \caption{两列并排的四张小图}</span><br><span class="line"> \label{fig:subfigure_example4}</span><br><span class="line">\end{figure}</span><br><span class="line"> </span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/05/18/Q9vjLKRUynJDbXI.png" alt="04-两行四图并排.png"></p><h4 id="两行六图并排"><a href="#两行六图并排" class="headerlink" title="两行六图并排"></a>两行六图并排</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">\documentclass{ctexart}</span><br><span class="line">\usepackage{coffeelize}</span><br><span class="line">\usepackage{graphicx}</span><br><span class="line">\usepackage{subfigure}</span><br><span class="line"></span><br><span class="line">\begin{document}</span><br><span class="line"></span><br><span class="line">\begin{figure}[htbp]</span><br><span class="line"> \centering</span><br><span class="line"> \subfigure[图1]{\includegraphics[width=0.3\linewidth]{example-image-A}}\quad</span><br><span class="line"> \subfigure[图2]{\includegraphics[width=0.3\linewidth]{example-image-A}}\quad</span><br><span class="line"> \subfigure[图3]{\includegraphics[width=0.3\linewidth]{example-image-A}}</span><br><span class="line"> \\</span><br><span class="line"> \subfigure[图4]{\includegraphics[width=0.3\linewidth]{example-image-A}}\quad</span><br><span class="line"> \subfigure[图5]{\includegraphics[width=0.3\linewidth]{example-image-A}}\quad</span><br><span class="line"> \subfigure[图6]{\includegraphics[width=0.3\linewidth]{example-image-A}}</span><br><span class="line"> \caption{两列并排的六张小图}</span><br><span class="line"> \label{fig:subfigure_example4}</span><br><span class="line">\end{figure}</span><br><span class="line"> </span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/05/18/awT4oAp6u3C21kx.png" alt="05-两行六图并排.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;图片排版&quot;&gt;&lt;a href=&quot;#图片排版&quot; class=&quot;headerlink&quot; title=&quot;图片排版&quot;&gt;&lt;/a&gt;图片排版&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;搭配 &lt;a href=&quot;https://coffeelize.top/posts/9165505d.html&quot;&gt;coffeelize.sty&lt;/a&gt; 宏包使用&lt;/li&gt;
&lt;li&gt;使用 subfigure 宏包&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="LaTeX" scheme="https://coffeelize.top/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>StackExchange 和它的游戏规则</title>
    <link href="https://coffeelize.top/posts/1925ecf2.html"/>
    <id>https://coffeelize.top/posts/1925ecf2.html</id>
    <published>2023-05-15T06:13:30.000Z</published>
    <updated>2023-05-18T00:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本文转载自：<a href="https://andnot.wordpress.com/2015/02/18/stackexchange%e5%92%8c%e5%ae%83%e7%9a%84%e6%b8%b8%e6%88%8f%e8%a7%84%e5%88%99/">StackExchange 和它的游戏规则 | 与非的零空间</a>，转载前已征得原作者同意</p><p>我们都明白一个道理：没有规矩，不成方圆。这句话是在讲规则的重要性，规则定好了，怎么玩也玩不脱，规则没定好或者干脆没有规则，那大家就没法再愉快地玩耍了。问题就在于好的游戏规则不好制定。这很像编程，一个程序只有在合理的逻辑关系下才能跑通，跑起来还不够，如果写代码的时候没有考虑周全，迟早会碰到 bug；当事关人类行为之时，潜在的 bug 就更多了，比如自私、虚荣、懒惰…… 如何能找到一套解决方案，即使不能消除这些 bug，至少也要将之压到最低，是每一个人类社区的管理者都要考虑的问题，这个社区往大了说，可以是一个国家，往小了说，可能仅仅是一家问答网站。</p><span id="more"></span><h3 id="数量与质量"><a href="#数量与质量" class="headerlink" title="数量与质量"></a>数量与质量</h3><p>问答类网站是近年来发展势头很猛的一类在线社区，这类网站的崛起是伴随着互联网整体信息量的冗余而愈发显著的。用 <a href="https://zh.wikipedia.org/zh/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8">亚伦・斯沃茨</a> 的话说，就是互联网的当下问题不是大众能否发出声音，而是发声的源头太多，人们想要从这些庞杂的信息中提取出有用的东西出来是一件极其困难的事情。搜索引擎的出现为找到正确信息提供了有力支持，另一类寻找信息的工具就是问答网站，一问一答，从来都是人类交流的最有效手段，相比搜索引擎查找出来的近似结果，一个精准问题所引出的有针对性的回答势必更有帮助。</p><p>目前问答网站已经有很多，国内最大的当属百度知道，可是用过百度知道的人都不免发现，这个网站的回答质量不是一般的良莠不齐，而且普遍水准不高。国内比较靠谱的问答网站可能是近年来兴起的知乎，这个网站上线以来给人的感觉是干货比较多，原创也不少，与国内网络社区普遍的浮躁氛围迥异，因此被寄予厚望。我也是这个网站开放注册后的首批用户之一，可是两年多用下来，我也和网站的其他老用户一样，明显感到知乎的问答质量在逐渐降低。</p><p>有人说是因为随着知乎注册用户的增多，大量低水平用户涌入导致。一开始我也觉得是这样，那些问问题不经过大脑思考，回答问题只知道复制粘贴的人，说句不好听的，正如夏洛克所言，「拉低了整条街的智商」。可是当我后来发现了 <a href="http://stackoverflow.com/">Stackoverflow</a> 这个网站后，我才明白关键原因并不在于用户水平，国外也有大量的低端用户，同样也是神棍伴民科齐飞，大忽悠与脑残粉横行。而 Stackoverflow 自 2008 年成立以来，始终保持超高问答水准的原因，在于它在上线之时，就制定了一套用心良苦的游戏规则。</p><h3 id="制度的力量"><a href="#制度的力量" class="headerlink" title="制度的力量"></a>制度的力量</h3><p>Stackoverflow 是一个编程领域的问答社区，在其之上还有一个母站，叫做 <a href="http://stackexchange.com/">StackExchange</a>，管理着几十个大大小小的问答社区（参见 <a href="http://stackexchange.com/sites">这里</a>），Stackoverflow 是其中成立最早、规模最大的一个子站，其他的所有子站在形式上都与 Stackoverflow 保持一致，它们的主题各异，但社区制度是同一的，是一种基于声誉值（reputation）的激励制度，这里简述如下：</p><ul><li>新注册用户只有 1 声誉，此时你除了提问啥也干不了；</li><li>当你提出来的问题被人顶起一次，可以获得 5 声誉；</li><li>积累够 15 声誉时，你才能去顶别人的问题及回答；</li><li>当你的回答被顶一次时，可以获得 10 声誉；</li><li>如果你的回答被提问者采纳为答案，则可获得 15 声誉，同时提问者也可获得 2 声誉；</li><li>如果你的回答被反对，则声誉 -2，同时反对你的人声誉也跟着 -1；</li><li>如果你的问题被反对，则声誉 -2；</li><li>如果你的问答被至少六个人标记为垃圾，则一次性减去 100 声誉。</li></ul><p>此外还有一些额外的奖惩制度，比如我刚刚使用 Stackoverflow 时，问了一些没有认真准备的问题，结果很快就被人踩了，我心想这不行啊，本来就不多的声誉值再踩几下就没了…… 于是我立即删除了自己的问题，令我没有想到的是，不仅之前被扣的声誉值又返还给我，网站还额外奖励了 2 声誉，奖励的理由是我接纳了本社区的「同行评审」意见，主动删除低质量问题。当时我就惊呆了，「同行评审」这个词我以前仅仅在涉及到学术出版时才会遇见啊。</p><p>你可能会问，那么利用它这个漏洞不就可以无限刷声誉了吗，严谨的设计者当然不会犯这样的错误，当我问下一个问题时，网站在最醒目的地方告诫我，由于我问了过多的低水平问题（- -III），这个帐号正处于危险状态，我的下一个问题必须内容翔实有针对性，否则如果再被人反对，将永久失去提问资格。这个警告确实让我认真了起来，我于是拿出写论文的诚意，写了一个既有代码片段又有若干示意图的问题。果然，我的诚意也换来了别人的诚意，这个问题在很短时间内就获得了多人的回复，完美解决了我的疑问，同时也解除了我的帐户危机。</p><p>那么，我如果很讨厌某个用户，能否通过不断踩他的问题和答案让他的账户变成危险状态呢，这在其他的网络社区可是屡见不鲜的事情。然而在 StackExchange 则没有可能，它有一整套防止私人攻击的规则，比如你要是反对了某人的答案，则除了扣他 2 声誉，你自己也要扣去 1 声誉，这样你在踩别人的时候，必然会三思而后行；如果你真的对某人怀恨在心，只要是他的问题你就反对，那怎么办？StackExchange 不允许这种情况发生，你根本无法完成这样的操作。甚至不仅是持续反对某人，你也无法持续赞同某人，这样的行为被称为「投票欺诈」（voting fraud），系统会严格禁止此类行为，以保证问答的客观性。</p><h3 id="自治、自制"><a href="#自治、自制" class="headerlink" title="自治、自制"></a>自治、自制</h3><p>由于 StackExchange 是一个知识型社区，它最关心的必然是网站内容的质量，所以如何规避低端问答一定是网站设计者首要考虑的问题。很多同类社区在发展初期由于比较小众，用户水平较高，即使出现低质量内容，管理员也能及时控制；然而一旦用户增多，内容覆盖范围扩大，这个问题就没法解决了。首先管理员根本来不及控制不断涌现的内容，其次他们也未必有那个水平去做判断。</p><p>StackExchange 采用基于声誉值的管理制度则比较完善地解决了这个问题。初级用户不能点赞的设定，表明了网站对普通网民的不信任，这种不信任是合理的，毕竟有那么多曾经优秀的社区都被网络水军们给糟蹋了；你如果仅仅是来寻找答案的，那没问题，网站的一切内容全部公开，甚至做了 SEO，你用 Google 就能搜到 StackExchange 的任何一个问答。但你如果想对 StackExchange 有所贡献，就不那么简单了，你必须证明自己具备这个资格，如何证明？提出好问题。只有好问题才会吸引人来作答，才会被人顶起，才能获得最初的声誉。</p><p>StackExchange 对问问题有着严格的规定，比如提问前必须搜索已有问答，避免问重复问题，避免问与社区主题无关的问题，避免问范围模糊的问题；此外问题描述要详实具体，给出例证，要具有可重现性；语言方面还要过关，不能词不达意，也不能啰啰嗦嗦…… 这么多规定简直像是对学术论文的要求，规则制定者一定笃信只有好的问题才能引出好的答案。那么这么严苛的规定不怕把用户吓跑吗？不怕，因为吓跑的本来就不是 StackExchange 的目标用户群，这毕竟是个知识型社区，不是普通的社交网络，用户数量从来都不是它关心的，高质量用户数量才是它关心的。事实上，StackExchange 的游戏规则非但没有吓跑用户，反而正在吸引越来越多的人参与其中。</p><p>在我看来，这种用户自治的游戏规则是最高明的管理策略，社区建设者只用把平台搭建好，剩下的工作就交给广大用户，而真正愿意参与这个社区的用户都必然是认真对待的，声誉值越高的用户，责任感也越强，想要获得高的声誉值，就得懂得自制，按着游戏规则玩，慢慢积累。</p><p>你可能会奇怪，既然问个问题都如此麻烦，为何我还要在上面花费时间？原因有二：</p><p>首先，对于这种业界公认的知识型社区，由于它的干货比重远远超出同类网站，其用户的声誉值便也有了独特的含金量，就好比一个项目被 fork 的次数之于 GitHub，声誉值在这里可以说明一切。你若能在自己的简历中写上 Stackoverflow 声誉值过万，任何一家用人单位都不会视而不见。</p><p>其次，并非所有人做什么事都要有所回报，这有点类似去问那些编辑维基百科的志愿者为何要花自己时间去做这种费力不讨好的事情。现在互联网上各种社区层出不穷，质量也是参差不齐，好不容易出现一个用户都那么认真对待的社区，当然倍受欢迎，因为这上面的讨论氛围是无可比拟的，一个问题问出去，可能几分钟内就有人回复，有的是指出你提问的不足之处，有的是给出可能有帮助的参考资料，甚至还有帮你纠正英语语法错误的…… 在这样的社区中，可能要比平时多花几倍时间才能完成一次提问，但你所收获的将更多。</p><p>这，才是真正的「人人为我，我为人人。」</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文转载自：&lt;a href=&quot;https://andnot.wordpress.com/2015/02/18/stackexchange%e5%92%8c%e5%ae%83%e7%9a%84%e6%b8%b8%e6%88%8f%e8%a7%84%e5%88%99/&quot;&gt;StackExchange 和它的游戏规则 | 与非的零空间&lt;/a&gt;，转载前已征得原作者同意&lt;/p&gt;
&lt;p&gt;我们都明白一个道理：没有规矩，不成方圆。这句话是在讲规则的重要性，规则定好了，怎么玩也玩不脱，规则没定好或者干脆没有规则，那大家就没法再愉快地玩耍了。问题就在于好的游戏规则不好制定。这很像编程，一个程序只有在合理的逻辑关系下才能跑通，跑起来还不够，如果写代码的时候没有考虑周全，迟早会碰到 bug；当事关人类行为之时，潜在的 bug 就更多了，比如自私、虚荣、懒惰…… 如何能找到一套解决方案，即使不能消除这些 bug，至少也要将之压到最低，是每一个人类社区的管理者都要考虑的问题，这个社区往大了说，可以是一个国家，往小了说，可能仅仅是一家问答网站。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Research" scheme="https://coffeelize.top/tags/Research/"/>
    
    <category term="Thinking" scheme="https://coffeelize.top/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>Zotero 学习笔记</title>
    <link href="https://coffeelize.top/posts/a6f9f7b7.html"/>
    <id>https://coffeelize.top/posts/a6f9f7b7.html</id>
    <published>2023-04-23T12:56:30.000Z</published>
    <updated>2023-08-02T06:16:58.499Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>茉莉花 Jasminum 插件：<a href="https://github.com/l0o0/jasminum">GitHub - l0o0/jasminum: A Zotero add-on to retrive CNKI meta data. 一个简单的 Zotero 插件，用于识别中文元数据</a></li><li> zotfile 插件：<a href="https://github.com/jlegewie/zotfile">GitHub - jlegewie/zotfile: Zotero plugin to manage your attachments: automatically rename, move, and attach PDFs (or other files) to Zotero items</a></li><li>Zutilo 插件：<a href="https://github.com/wshanks/Zutilo">GitHub - wshanks/Zutilo: Zotero plugin providing some additional editing features</a></li><li>scite-zotero-plugin 插件：<a href="https://github.com/scitedotai/scite-zotero-plugin">GitHub - scitedotai/scite-zotero-plugin: scite zotero plugin</a></li><li>zotero-better-bibtex 插件：<a href="https://retorque.re/zotero-better-bibtex/">Better BibTeX for Zotero :: Better BibTeX for Zotero</a></li><li> 个人博客：<a href="https://jieli-matrix.github.io/automatic-insert-bib/">使用 Zotero 自动导出参考文献到 Word/Latex | Trace of Life</a></li><li> 个人博客：<a href="https://liam.page/2020/03/30/writing-manuscript-in-Markdown-and-typesetting-with-LaTeX/">以 Markdown 撰写文稿，以 LaTeX 排版</a> 以及 <a href="https://coffeelize.top/posts/23aacf40.html">以 Markdown 撰写文稿，以 LaTeX 排版</a></li><li>个人博客：<a href="https://snailwish.com/291/">Zotero 插件 Bibtex for Zotero 介绍和安装</a></li><li>个人博客：<a href="http://47.98.142.167/238/">加入参考文献，Markdown 完美转化成 Word - 倔强的小蜗牛</a></li><li>个人博客：<a href="https://liuyun16.github.io/tools/2018-2-24-atom-markdown-zotero/">使用 Markdown 写作并插入参考文献（atom+pandoc+Zotero） &lt; 岁月流韵</a></li><li>少数派：<a href="https://sspai.com/post/60825">使用 Zotero 在 Markdown 中优雅地处理参考文献 - 少数派</a></li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    <category term="Research" scheme="https://coffeelize.top/categories/Research/"/>
    
    
    <category term="Research" scheme="https://coffeelize.top/tags/Research/"/>
    
  </entry>
  
  <entry>
    <title>查询国家标准</title>
    <link href="https://coffeelize.top/posts/ffdb85c7.html"/>
    <id>https://coffeelize.top/posts/ffdb85c7.html</id>
    <published>2023-04-23T12:36:40.000Z</published>
    <updated>2023-09-15T08:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="国家标准全文公开系统"><a href="#国家标准全文公开系统" class="headerlink" title="国家标准全文公开系统"></a>国家标准全文公开系统</h3><p>官网：<a href="https://openstd.samr.gov.cn/bzgk/gb/">国家标准全文公开系统</a></p><p>有些标准在这个公开系统上也无法下载，那么可以尝试去 <a href="https://www.freebz.net/">标准下载网</a> 这个网站下载，对于不收费的标准，每天可免费下载一篇</p><p>提示：下载标准前，可以上谷歌搜索。比如查询泡沫玻璃抗压强度，很可能别人已经做过了，会给出一些标准名称什么的，那样的话就可以直接拿着这个标准名进行搜索了</p><p><a href="http://www.bzfxw.com/">学兔兔_(原标准分享网)_专注工程技术学习网站_论文资料标准分享网</a> 每天可以免费下载两篇标准</p>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="Research" scheme="https://coffeelize.top/tags/Research/"/>
    
  </entry>
  
  <entry>
    <title>PS 科研绘图</title>
    <link href="https://coffeelize.top/posts/62a8127a.html"/>
    <id>https://coffeelize.top/posts/62a8127a.html</id>
    <published>2023-04-23T12:08:40.000Z</published>
    <updated>2023-05-15T06:22:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li><p>标尺：Ctrl + R</p></li><li><p>反选：Ctrl + Shift + I</p></li><li><p>参考线：从标尺处拖拉可新建参考线；</p></li><li><p>显示 / 隐藏参考线：Ctrl + ；</p></li><li><p>内容填充：框选，右键，填充</p></li><li><p>复制图层：Ctrl + J</p></li><li><p>将框选的图层复制到新文档：先框选 –&gt; Ctrl + J –&gt; Ctrl + N –&gt; 从剪切板导入。这样做的目的是框选的图层长宽多大，新文档的长宽就是多大，不会有大量多余的空白部分</p></li><li><p>按比例裁剪：裁剪前可设置裁剪的长宽比（Visio 中似乎没有这个功能，就只能在 PS 中操作了）</p></li><li><p>对图形进行变换操作：Ctrl + T</p></li><li><p>对图形进行连续相同的变换操作：Ctrl + Shift + T</p></li><li><p>取消选区：Ctrl + D</p></li><li><p>恢复选区：Ctrl + Shift + D</p></li></ul>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="绘图" scheme="https://coffeelize.top/tags/%E7%BB%98%E5%9B%BE/"/>
    
    <category term="Research" scheme="https://coffeelize.top/tags/Research/"/>
    
  </entry>
  
  <entry>
    <title>内部类 &amp; Lambda 表达式简明笔记</title>
    <link href="https://coffeelize.top/posts/fb200558.html"/>
    <id>https://coffeelize.top/posts/fb200558.html</id>
    <published>2023-02-02T11:47:30.000Z</published>
    <updated>2023-05-18T00:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类的基本使用"><a href="#内部类的基本使用" class="headerlink" title="内部类的基本使用"></a>内部类的基本使用</h3><p>内部类概念：在一个类中定义一个类</p><p>比如，在一个类 A 的内部定义一个类 B，类 B 就被称为内部类。内部类定义格式如下：</p><span id="more"></span><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class 外部类名{</span></span><br><span class="line"><span class="comment"> 修饰符 class 内部类名{</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> }</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line"> <span class="comment">//此处的Inner就是所说的内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>内部类的访问特点</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象</li></ul><p>1、示例代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Inner</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">     <span class="comment">//此处编译器报错</span></span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"Inner..show"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上代码中，为什么这里编译器会报错呢：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inner i = <span class="keyword">new</span> Inner();</span><br></pre></td></tr></tbody></table></figure><p>因为类名没有写全 –&gt; 为什么呢？举例如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Inner</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer2</span></span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时创建 Inner 对象时，编译器都懵掉了，你到底是想要创建那个类中的 Inner 类 –&gt; 需要我们正确书写格式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Inner</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//创建内部类的格式</span></span><br><span class="line">        <span class="comment">//外部类名.内部类类名 对象名 = new 外部类对象().new 内部类对象;</span></span><br><span class="line">        Outer.Inner i = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>emm，创建内部类为什么格式那么复杂:-)。如下是演示内部类变量、内部类方法的访问方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Inner</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">//创建内部类的格式  </span></span><br><span class="line">        <span class="comment">//外部类名.内部类类名 对象名 = new 外部类对象().new 内部类对象;  </span></span><br><span class="line">        Outer.Inner i = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;  </span><br><span class="line">        <span class="comment">//访问内部类变量  </span></span><br><span class="line">        System.out.println(i.num);  </span><br><span class="line">        <span class="comment">//访问内部类方法  </span></span><br><span class="line">        i.show();  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="comment">//内部类  </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{  </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{  </span><br><span class="line">            System.out.println(<span class="string">"Inner...show"</span>);  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>内部类是可以直接使用外部类中的成员变量的，代码如下：</p><p>可以看到，调用内部类方法时，可以访问到外部类中的 a 变量（包括私有的成员变量）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Inner</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">//创建内部类的格式  </span></span><br><span class="line">        <span class="comment">//外部类名.内部类类名 对象名 = new 外部类对象().new 内部类对象;  </span></span><br><span class="line">        Outer.Inner i = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;  </span><br><span class="line">        <span class="comment">//访问内部类变量  </span></span><br><span class="line">        System.out.println(i.num);  </span><br><span class="line">        <span class="comment">//访问内部类方法  </span></span><br><span class="line">        i.show();  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{ </span><br><span class="line"> <span class="comment">//外部类中私有的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">10</span>;  </span><br><span class="line">    <span class="comment">//内部类  </span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{  </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{  </span><br><span class="line">            System.out.println(<span class="string">"Inner...show"</span>);</span><br><span class="line">            <span class="comment">//内部类可以直接访问外部类的成员变量（包括私有的成员变量）  </span></span><br><span class="line">            System.out.println(<span class="string">"外部类中的成员变量"</span> + a);  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序输出</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line">Inner...show</span><br><span class="line">外部类中的成员变量<span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>按照内部类在类中定义的位置不同，可以分为如下两种形式</p><ul><li>在类的成员位置：成员内部类</li><li>在类的局部位置：局部内部类</li></ul><p>外界创建成员内部类格式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类名.内部类名 对象名 = 外部类对象.内部类对象;</span></span><br><span class="line">Outer.Inner oi = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>成员内部类，也属于（成员），既然是成员就可以被一些修饰符所修饰，比如 private 和 static</p><h4 id="私有成员内部类"><a href="#私有成员内部类" class="headerlink" title="私有成员内部类"></a>私有成员内部类</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Innerclass</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">     <span class="comment">//此处编译错误  </span></span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{  </span><br><span class="line">    <span class="comment">//私有成员内部类  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{  </span><br><span class="line">            System.out.println(<span class="string">"inner..show"</span>);  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此处，创建成员内部类对象时编译错误<br>因为 private 是同一类中可见 –&gt; 也就是说只在 Outer 类中是可见的。那么外界如何创建这个内部类对象呢：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Innerclass</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();  </span><br><span class="line">        <span class="comment">//调用外部类中的方法，利用类中的方法来间接访问内部类  </span></span><br><span class="line">        outer.method();  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{  </span><br><span class="line">    <span class="comment">//私有成员内部类  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{  </span><br><span class="line">            System.out.println(<span class="string">"inner..show"</span>);  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>{  </span><br><span class="line">        <span class="comment">//因为和Inner类都属于Outer类，所以可以直接这样创建  </span></span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="comment">//访问类中的方法  </span></span><br><span class="line">        i.show();  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>私有成员内部类访问：在自己所在的外部类中创建对象访问</p><h3 id="静态成员内部类"><a href="#静态成员内部类" class="headerlink" title="静态成员内部类"></a>静态成员内部类</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3Innerclass</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">// 外部类名.内部类名 对象名 = new 外部类名.内部类名();  </span></span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();  </span><br><span class="line">        oi.show();  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{  </span><br><span class="line">    <span class="comment">//静态成员内部类  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{  </span><br><span class="line">            System.out.println(<span class="string">"inner..show"</span>);  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner oi = <span class="keyword">new</span> Outer().n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>; <span class="comment">//错误，这是没有加static修饰符时的方式</span></span><br><span class="line">Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();       <span class="comment">//正确</span></span><br></pre></td></tr></tbody></table></figure><ul><li>因为 Inner 不是 private 修饰的，所以外部可以访问</li><li>因为 Inner 是 static 修饰的，可以不用创建类的对象『new Outer ()』来访问，通过类『Outer』直接就可以访问了</li></ul><p>对于 Staic 修饰的其实很好调用，比如静态内部类中还有一个静态方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3Innerclass</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">// 外部类名.内部类名 对象名 = new 外部类名.内部类名();  </span></span><br><span class="line">        Outer.Inner oi = <span class="keyword">new</span> Outer.Inner();  </span><br><span class="line">        <span class="comment">//类名一路调用即可</span></span><br><span class="line">        Outer.Inner.method();  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{  </span><br><span class="line">    <span class="comment">//静态成员内部类  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>{  </span><br><span class="line">            System.out.println(<span class="string">"inner..method"</span>);  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类名一路调用即可，都是Static的，无需创建对象，直接类名调用</span></span><br><span class="line">Outer.Inner.method(); </span><br></pre></td></tr></tbody></table></figure><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>静态成员内部类访问：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 对象名 = <span class="keyword">new</span> 外部类名.内部类名(); </span><br></pre></td></tr></tbody></table></figure><p>静态成员内部类中的静态方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名.方法名();</span><br></pre></td></tr></tbody></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类定义位置：局部内部类是在方法中定义的类，所以外界是无法直接访问的，需要在方法内部创建对象并使用</p><p>该类可以直接访问外部类的成员，也可以访问方法内地局部变量</p><p>1、代码展示：调用局部内部类中的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4Innerclass</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();  </span><br><span class="line">        o.method();  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>{  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//写在method当中的局部内部类  </span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{  </span><br><span class="line">                System.out.println(<span class="string">"show..."</span>);  </span><br><span class="line">            }  </span><br><span class="line">        }  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//方法内部可以访问Inner类  </span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();  </span><br><span class="line">        inner.show();  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为局部内部类的访问范围仅仅是方法体中的范围，范围如下图所示</p><p><img data-src="https://s2.loli.net/2023/02/03/Cl7DhR51joyIWzY.png" alt="01-局部内部类的访问范围.png"></p><p>2、代码展示：局部内部类访问不同变量</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4Innerclass</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        o.method();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>{</span><br><span class="line">    <span class="comment">// 类中的成员变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 方法中的局部变量</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写在method当中的局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>{</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">                System.out.println(<span class="string">"show..."</span>);</span><br><span class="line">                <span class="comment">// 可以访问（嵌在里边的可以访问外边的）</span></span><br><span class="line">                System.out.println(a);</span><br><span class="line">                <span class="comment">// 可以访问方法中的局部变量</span></span><br><span class="line">                System.out.println(b);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法内部可以访问Inner类</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用</li><li>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</li><li>局部内部类我们平时是很少编写的，因为局部内部类实在是太受限了；在看源码的过程中也很少会见到局部内部类，讲他的作用是为后面的匿名内部类打基础。因为匿名内部类属于一种特殊的局部内部类</li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类本质上说一个特殊的局部内部类（定义在方法内部）<br>前提：需要存在一个接口或类</p><p>格式如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">new 类名或接口名(){</span></span><br><span class="line"><span class="comment"> 重写方法;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Inter(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>{}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>1、代码演示：正常使用接口中的方法需要几步</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5Innerclass</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        InterImpl ii = <span class="keyword">new</span> InterImpl();</span><br><span class="line">        ii.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span> <span class="keyword">implements</span> <span class="title">Inner</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"InterImpl 重写的show方法"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>1）创建实现类，通过 implements 关键字去实现接口<br>2）重写方法<br>3）创建实现类对象<br>4）调用重写后的方法</p><p>可以看到，想要使用接口中的方法还是比较复杂的。而如果是通过匿名内部类，就可以化简为 1 步</p><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test5Innerclass {  </span><br><span class="line">    public static void main(String[] args) {  </span><br><span class="line"><span class="deletion">-       InterImpl ii = new InterImpl();  </span></span><br><span class="line"><span class="deletion">-       ii.show();  </span></span><br><span class="line">        //匿名内部类  </span><br><span class="line"><span class="addition">+       new Inner(){  </span></span><br><span class="line"><span class="addition">+           @Override  </span></span><br><span class="line"><span class="addition">+           public void show() {  </span></span><br><span class="line"><span class="addition">+               System.out.println("匿名内部类中的show方法");  </span></span><br><span class="line"><span class="addition">+           }  </span></span><br><span class="line"><span class="addition">+       }.show();  </span></span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line">interface Inner{  </span><br><span class="line">    void show();  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="deletion">-class InterImpl implements Inner{  </span></span><br><span class="line"><span class="deletion">-    @Override  </span></span><br><span class="line"><span class="deletion">-    public void show() {  </span></span><br><span class="line"><span class="deletion">-        System.out.println("InterImpl 重写的show方法");  </span></span><br><span class="line"><span class="deletion">-    }  </span></span><br><span class="line"><span class="deletion">-}</span></span><br></pre></td></tr></tbody></table></figure><p>我们重点分析这几行代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Inner(){</span><br><span class="line"> <span class="comment">//『实现接口的类』中需要重写的方法</span></span><br><span class="line">}.show();</span><br></pre></td></tr></tbody></table></figure><p>可以认为</p><p><img data-src="https://s2.loli.net/2023/02/03/Ff1O3SryMBuKzRe.png" alt="02-正常方式访问接口中的方法VS匿名内部类方式.png"></p><p>匿名内部类的理解：将继承（或实现）、方法重写、创建对象这三步放在了一步都当完成</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Inner(){}; --&gt; 相当于创建了一个实现了接口的实现类对象</span><br><span class="line"><span class="keyword">new</span> Inner(){}.show(); --&gt; 实现类对象调用方法</span><br></pre></td></tr></tbody></table></figure><p>2、代码演示：如果接口中有多个方法，匿名内部类最多只能调用其中的一个方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5Innerclass</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Inner(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类中的show1方法"</span>);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类中的show2方法"</span>);</span><br><span class="line">            }</span><br><span class="line">  <span class="comment">//此处只能调用一次方法，就相当于"对象.方法"，而不能"对象.方法1.方法2"</span></span><br><span class="line">        }.show1();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时，我就想调用其中的多个方法呢，怎么办</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5Innerclass</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//Inner i 接口的引用；new Inner(){} 实现类对象 --&gt; 父类的引用指向了一个子类的对象（多态）  </span></span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner(){  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span> </span>{  </span><br><span class="line">                System.out.println(<span class="string">"匿名内部类中的show1方法"</span>);  </span><br><span class="line">            }  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>{  </span><br><span class="line">                System.out.println(<span class="string">"匿名内部类中的show2方法"</span>);  </span><br><span class="line">            }  </span><br><span class="line">        };  </span><br><span class="line">  </span><br><span class="line">        i.show1();  </span><br><span class="line">        i.show2();  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inner</span></span>{  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>案例小结：如果说一个接口当中有多个方法，如果使用匿名内部类的方式将其中的多个方法都进行调用，可以在匿名内部类前面通过一个父类或父接口的引用去接收一下，这样就能以多态的形式将匿名内部类接受过来。通过引用就可以调其中的方法了</p><h4 id="匿名内部类在开发中的使用"><a href="#匿名内部类在开发中的使用" class="headerlink" title="匿名内部类在开发中的使用"></a>匿名内部类在开发中的使用</h4><p>当方法的形式参数是接口或者抽象类时，可以将匿名内部类作为实际参数进行传递</p><p>1、代码演示</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSwimming</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//调用方法(参数要求为实现类对象，这里我们使用匿名内部类的方式)  </span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> Swimming(){  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>{  </span><br><span class="line">                System.out.println(<span class="string">"GoGoGo!"</span>);  </span><br><span class="line">            }  </span><br><span class="line">        });  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//实际参数为接口的方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goSwimming</span><span class="params">(Swimming swimming)</span></span>{  </span><br><span class="line">        swimming.swim();  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Swimming</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此处蓝色标记的就是创建了一个匿名内部类，将其作为 goSwimming () 方法的参数</p><p><img data-src="https://s2.loli.net/2023/02/03/XUTPBdKCL6u2yYf.png" alt="03-匿名内部类作为方法参数.png"></p><p>既然匿名内部类作为方法参数，其格式比较固定，编译器也为我们提供了代码提示：只要输入 <code>new 父接口名</code>，根据提示回车即可自动生成代码段</p><p><img data-src="https://s2.loli.net/2023/02/03/VMR4wpHSrA3W6xK.gif" alt="04-匿名内部类作为方法参数代码快速生成.gif"></p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式可以认为是对匿名内部类的优化，在了解这一块知识前，请先熟悉匿名内部类</p><h3 id="匿名内部类和-Lambda-表达式"><a href="#匿名内部类和-Lambda-表达式" class="headerlink" title="匿名内部类和 Lambda 表达式"></a>匿名内部类和 Lambda 表达式</h3><p>1、代码演示：匿名内部类和 Lambda 表达式的使用方式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSwimming</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、使用匿名内部类的方式</span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> Swimming() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"铁汁, 我们去游泳吧"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、使用Lambda表达式，此处可以理解为是对匿名内部类的优化</span></span><br><span class="line">        goSwimming(() -&gt; System.out.println(<span class="string">"铁汁, 我们去游泳吧"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goSwimming</span><span class="params">(Swimming swimming)</span> </span>{</span><br><span class="line">        swimming.swim();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Swimming</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>小结：Lambda 表达式可以使关注点更加明确，为什么这么说呢，请看一下分析：</p><p>1、对于匿名内部类的方式（面向对象思想，以什么形式去做）<br>1）方法要一个接口，我得给个接口的实现类对象<br>2）创建匿名内部类对象，重新方法<br>3）方法要干嘛呢，其实就是打印一句话</p><p>而其实，我们想要做的仅仅是打印一句话，也就是想要完成第 3 步，而第 1 步和第 2 步都是附加的操作，是 “不得不” 才这样写的</p><p>2、对于 Lambda 表达式（函数式编程思想，更多关注做什么）</p><h3 id="Lambda-表达式的标准格式"><a href="#Lambda-表达式的标准格式" class="headerlink" title="Lambda 表达式的标准格式"></a>Lambda 表达式的标准格式</h3><p><img data-src="https://s2.loli.net/2023/02/03/aiG5A3tcFsVOTwl.png" alt="05-匿名内部类与Lambda表达式.png"></p><p>组成 Lambda 表达式的三要素：形式参数、箭头、代码块</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(形式参数) -&gt; {代码块}</span><br></pre></td></tr></tbody></table></figure><ul><li>形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</li><li> -&gt;：表示将小括号中的形式参数传到大括号的代码块中进行处理</li><li>代码块：是我们具体要做到事情，也就是方法体中的内容</li></ul><p>Lambda 表达式的使用前提：</p><ul><li>有一个接口（也就表明 Lambda 只能操作接口，不能操作类）</li><li>接口中有且仅有一个抽象方法</li></ul><h3 id="Lambda-带参数无返回值"><a href="#Lambda-带参数无返回值" class="headerlink" title="Lambda 带参数无返回值"></a>Lambda 带参数无返回值</h3><p>1、代码示例：</p><ul><li>接口中有且只有一个方法，方法有一个参数，无返回值</li><li>采用匿名内部类和 Lambda 表达式分别进行实现 </li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHandlerDemo</span> </span>{  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">// 匿名内部类的实现方式  </span></span><br><span class="line">        useStringHandler(<span class="keyword">new</span> StringHandler() {  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span> </span>{  </span><br><span class="line">                System.out.println(<span class="string">"我是匿名内部类"</span> + msg);  </span><br><span class="line">            }  </span><br><span class="line">        });  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Lambda实现方式  </span></span><br><span class="line">        useStringHandler((String msg)-&gt;{System.out.println(<span class="string">"我是Lambda表达式"</span> + msg);});  </span><br><span class="line">        useStringHandler( (msg) -&gt; System.out.println(<span class="string">"我是Lambda表达式"</span> + msg));  </span><br><span class="line">        useStringHandler( msg -&gt; System.out.println(<span class="string">"我是Lambda表达式"</span> + msg));  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useStringHandler</span><span class="params">(StringHandler stringHandler)</span></span>{  </span><br><span class="line">        stringHandler.printMessage(<span class="string">"coffeelize"</span>);  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StringHandler</span> </span>{  </span><br><span class="line">    <span class="comment">//带参数无返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(String msg)</span></span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Lambda-无参数有返回值"><a href="#Lambda-无参数有返回值" class="headerlink" title="Lambda 无参数有返回值"></a>Lambda 无参数有返回值</h3><p>如果 Lambda 所操作的接口中的方法，有返回值，一定要通过 return 语句，否则会出现编译错误  </p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNumHandlerDemo</span> </span>{  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">//匿名内部类实现方式  </span></span><br><span class="line">        useRandomNumHandler(<span class="keyword">new</span> RandomNumHandler() {  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>{  </span><br><span class="line">                Random r = <span class="keyword">new</span> Random();  </span><br><span class="line">                <span class="comment">//产生一个1-10的随机数  </span></span><br><span class="line">                <span class="keyword">int</span> num = r.nextInt(<span class="number">10</span>) + <span class="number">1</span>;  </span><br><span class="line">                <span class="keyword">return</span> num;  </span><br><span class="line">            }  </span><br><span class="line">        });  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//Lambda表达式实现方式  </span></span><br><span class="line">        useRandomNumHandler( () -&gt; {  </span><br><span class="line">                Random r = <span class="keyword">new</span> Random();  </span><br><span class="line">                <span class="keyword">int</span> num = r.nextInt(<span class="number">10</span>) + <span class="number">1</span>;  </span><br><span class="line">                <span class="comment">// 注意: 如果lambda所操作的接口中的方法, 有返回值, 一定要通过return语句，否则会出现编译错误  </span></span><br><span class="line">                <span class="keyword">return</span> num;  </span><br><span class="line">        } );  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useRandomNumHandler</span><span class="params">(RandomNumHandler randomNumHandler)</span></span>{  </span><br><span class="line">        <span class="keyword">int</span> result = randomNumHandler.getNumber();  </span><br><span class="line">        System.out.println(result);  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RandomNumHandler</span> </span>{  </span><br><span class="line">    <span class="comment">//无参数有返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Lambda-带参数带返回值"><a href="#Lambda-带参数带返回值" class="headerlink" title="Lambda 带参数带返回值"></a>Lambda 带参数带返回值</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorDemo</span> </span>{  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{  </span><br><span class="line">        <span class="comment">//匿名内部类的实现方式  </span></span><br><span class="line">        useCalculator(<span class="keyword">new</span> Calculator() {  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{  </span><br><span class="line">                <span class="keyword">return</span> a + b;  </span><br><span class="line">            }  </span><br><span class="line">        });  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//Lambda表达式实现方式  </span></span><br><span class="line">        useCalculator((<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;{  </span><br><span class="line">            <span class="keyword">return</span> a + b;  </span><br><span class="line">        });  </span><br><span class="line">  </span><br><span class="line">        useCalculator( (a,b) -&gt;  </span><br><span class="line">             a + b  </span><br><span class="line">        );  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useCalculator</span><span class="params">(Calculator calculator)</span></span>{  </span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(<span class="number">10</span>,<span class="number">20</span>);  </span><br><span class="line">        System.out.println(result);  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>{  </span><br><span class="line">    <span class="comment">//带参数，带返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到，以上代码中，第二种 Lambda 的书写更加简练，关于省略规则请往下看</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda表达式实现方式  </span></span><br><span class="line">useCalculator((<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;{  </span><br><span class="line"> <span class="keyword">return</span> a + b;  </span><br><span class="line">});  </span><br><span class="line"></span><br><span class="line">useCalculator( (a,b) -&gt;  </span><br><span class="line">  a + b  </span><br><span class="line">); </span><br></pre></td></tr></tbody></table></figure><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><ul><li>参数类型可以省略，但是有多个参数的情况下，不能只省略一个<ul><li>为什么可以省略呢？因为在接口中的方法中已经定义了参数类型，可以推导出来参数类型，所以可以省略</li></ul></li><li>如果参数有且仅有一个，那么小括号可以省略</li><li>如果代码块的语句只有一条，可以省略大括号和分号，甚至是 return<ul><li> 若有返回参数，要省略，大括号、分号和 return 一起省略</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h2&gt;&lt;h3 id=&quot;内部类的基本使用&quot;&gt;&lt;a href=&quot;#内部类的基本使用&quot; class=&quot;headerlink&quot; title=&quot;内部类的基本使用&quot;&gt;&lt;/a&gt;内部类的基本使用&lt;/h3&gt;&lt;p&gt;内部类概念：在一个类中定义一个类&lt;/p&gt;
&lt;p&gt;比如，在一个类 A 的内部定义一个类 B，类 B 就被称为内部类。内部类定义格式如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://coffeelize.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker 简明笔记</title>
    <link href="https://coffeelize.top/posts/f90fc61c.html"/>
    <id>https://coffeelize.top/posts/f90fc61c.html</id>
    <published>2023-01-10T09:24:30.000Z</published>
    <updated>2023-01-16T02:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>前置知识：SpringCloud</p><h2 id="初识-Docker"><a href="#初识-Docker" class="headerlink" title="初识 Docker"></a>初识 Docker</h2><span id="more"></span><h3 id="项目部署的问题"><a href="#项目部署的问题" class="headerlink" title="项目部署的问题"></a>项目部署的问题</h3><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突<ul><li>依赖关系复杂，容易出现兼容性问题</li></ul></li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题<ul><li>开发、测试、生产环境有差异</li></ul></li></ul><h4 id="Docker-解决依赖兼容问题"><a href="#Docker-解决依赖兼容问题" class="headerlink" title="Docker 解决依赖兼容问题"></a>Docker 解决依赖兼容问题</h4><p><strong>Docker 如何解决依赖的兼容问题的呢</strong>，采用了两个手段：</p><ul><li>将应用的 Libs（函数库）、Deps（依赖）、配置与应用一起 <strong>打包</strong></li><li>将每个应用放到一个 <strong>隔离</strong> 容器去运行，避免互相干扰</li></ul><p><img data-src="https://s2.loli.net/2023/01/12/FcPREX3drLv6sWm.png" alt="01-应用放在隔离带容器中运行.png"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的 Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了</p><h4 id="Docker-解决操作系统环境差异"><a href="#Docker-解决操作系统环境差异" class="headerlink" title="Docker 解决操作系统环境差异"></a>Docker 解决操作系统环境差异</h4><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><p><img data-src="https://s2.loli.net/2023/01/12/XjDYAhdfkLz42EH.png" alt="02-操作系统结构.png"></p><ul><li>计算机硬件：例如 CPU、内存、磁盘等</li><li>系统内核（内核与硬件交互，提供操作硬件指令）：所有 Linux 发行版的内核都是 Linux，例如 CentOS、Ubuntu、Fedora 等。内核可以与计算机硬件交互，对外提供 <strong>内核指令</strong>，用于操作计算机硬件</li><li>系统应用（系统应用封装内核指令为函数，便于程序员调用）：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便</li></ul><p>Ubuntu 和 CentOS 都是基于 Linux 内核，无非是系统应用不同，提供的函数库有差异。此时，如果将一个 Ubuntu 版本的 MySQL 应用安装到 CentOS 系统，MySQL 在调用 Ubuntu 函数库时，会发现找不到或者不匹配，就会报错了，<strong>那 Docker 如何解决不同系统环境问题的呢</strong>？</p><ul><li>Docker 将用户程序与所需要调用的系统 (比如 Ubuntu) 函数库一起打包</li><li> Docker 运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的 Linux 内核来运行</li></ul><p>那么就可以认为 Docer 打包好的程序包可以应用在任何 Linux 内核的操作系统上</p><p><img data-src="https://s2.loli.net/2023/01/12/9Fv3Mx27gHGnOkW.png" alt="03-Docker打包好的程序包可以运行在任一Linux内核的系统上.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Docker 是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><ul><li>镜像（Image，硬盘中的文件）：Docker 将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像</li><li>容器（Container，相当于进程）：镜像中的应用程序运行后形成的进程就是容器，只是 Docker 会给容器进程做隔离，对外不可见</li></ul><p><strong>镜像都是只读的</strong>，这样可以防止容器对镜像数据的写入，造成数据污染；如果容器需要写数据，可以从镜像中拷贝一份数据到自己的空间中，在本空间中进行读写操作</p><p><img data-src="https://s2.loli.net/2023/01/12/wg1I9Hf7enZRzv6.png" alt="04-镜像和容器.png"></p><h3 id="DockerHub"><a href="#DockerHub" class="headerlink" title="DockerHub"></a>DockerHub</h3><p>DockerHub 是一个官方的 Docker 镜像的托管平台。这样的平台称为 Docker Registry，国内也有类似于 DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a> 等</p><p>我们一方面可以将自己的镜像共享到 DockerHub，另一方面也可以从 DockerHub 拉取镜像<br><img data-src="https://s2.loli.net/2023/01/12/NgaKpJTAxshWt8n.png" alt="05-DockerHub.png"></p><h3 id="Docker-架构-1"><a href="#Docker-架构-1" class="headerlink" title="Docker 架构"></a>Docker 架构</h3><p>Docker 是一个 CS 架构的程序，由两部分组成</p><ul><li>服务端 (server)：Docker 守护进程，负责处理 Docker 指令，管理镜像、容器等</li><li>客户端 (client)：通过命令或 RestAPI 向 Docker 服务端发送指令。可以在本地或远程向服务端发送指令</li></ul><p><img data-src="https://s2.loli.net/2023/01/12/fOX7ZhIcWmk6xDP.png" alt="06-Docker架构.png"></p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。这里主要介绍 CentOS 安装 Docker</p><p>1.1、卸载（可选）</p><p>如果之前安装过旧版本的 Docker，可以使用下面命令卸载</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></tbody></table></figure><p><code>\</code> 表示命令没有结束还需要继续往下读（换行），命令太长可以通过 <code>\</code> 提高可读性</p><p>1.2、安装 yum-utils 工具</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></tbody></table></figure><p>1.3、设置下载的镜像源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i <span class="string">'s/download.docker.com/mirrors.aliyun.com\/docker-ce/g'</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">yum makecache fast</span><br></pre></td></tr></tbody></table></figure><p>1.4、安装 docker</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></tbody></table></figure><p>至此 docker 安装完毕</p><h3 id="启动-docker"><a href="#启动-docker" class="headerlink" title="启动 docker"></a>启动 docker</h3><p>Docker 应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙。启动 docker 前，一定要关闭防火墙！</p><p>1、关闭防火墙</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"># 禁止开机启动防火墙</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"># 查看防火墙状态</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></tbody></table></figure><p>2、启动 Docker</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  # 启动docker服务</span><br><span class="line"></span><br><span class="line">systemctl stop docker  # 停止docker服务</span><br><span class="line"></span><br><span class="line">systemctl restart docker  # 重启docker服务</span><br></pre></td></tr></tbody></table></figure><p>3、可通过查看 Docker 状态或 Docker 版本查看是否已经启动</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">docker -v</span><br></pre></td></tr></tbody></table></figure><h3 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h3><p>docker 官方镜像仓库网速较差，我们需要设置国内镜像服务，可参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">//将内容写入json文件中</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">{</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://5vycoa8o.mirror.aliyuncs.com"</span>]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure><h2 id="Docker-基本操作"><a href="#Docker-基本操作" class="headerlink" title="Docker 基本操作"></a>Docker 基本操作</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><h4 id="镜像名称"><a href="#镜像名称" class="headerlink" title="镜像名称"></a>镜像名称</h4><p>镜名称一般分两部分组成：<code>[repository]:[tag]</code>，在没有指定 tag 时，默认是 latest，代表最新版本的镜像。如这里的 mysql 就是 repository，5.7 就是 tag，合一起就是镜像名称，代表 5.7 版本的 MySQL 镜像</p><p><img data-src="https://s2.loli.net/2023/01/12/e1sEAnpQFOm28JB.png" alt="07-镜像名称的组成.png"></p><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><p>常见的镜像操作命令如图</p><p><img data-src="https://s2.loli.net/2023/01/12/dCaSEuzIOwcbf8R.png" alt="08-常用镜像指令.png"></p><ul><li>从镜像服务器拉去镜像：docker pull</li><li> 从本地文件构建镜像：docker build</li><li> 查看本地存在哪些镜像：docker images</li><li> 删除本地镜像：docker rmi</li><li> 推送镜像到镜像服务器：docker push</li><li> 将镜像打包成一个压缩包：docker save</li><li> 加载压缩包为镜像：docker load</li></ul><p>查看 docker 帮助文档</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看docker命令及简介</span></span><br><span class="line">docker --help</span><br><span class="line"><span class="comment">//查看具体的某一命令，比如这里详细查看images命令的功能</span></span><br><span class="line">docker images --help</span><br></pre></td></tr></tbody></table></figure><h4 id="案例：从-DockerHub-中拉取镜像"><a href="#案例：从-DockerHub-中拉取镜像" class="headerlink" title="案例：从 DockerHub 中拉取镜像"></a>案例：从 DockerHub 中拉取镜像</h4><p>需求：从 DockerHub 中拉取一个 nginx 镜像并查看</p><p>1、首先去镜像仓库搜索 nginx 镜像，比如 <a href="https://hub.docker.com/">Docker Hub Container Image Library | App Containerization</a></p><p><img data-src="https://s2.loli.net/2023/01/12/En6MHQAx7ucKbkY.png" alt="09-DockerHub拉取镜像.png"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里官方示例中没有指定版本，那么默认就是最新版</span></span><br><span class="line">docker pull nginx</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/01/12/a1j2ylNWkPuSIK3.png" alt="10-DockerHub搜索镜像.png"></p><p>2、查看镜像</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure><p>可以查看到本地中已经有 Nginx 镜像了</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    605c77e624dd   12 months ago   141MB</span><br></pre></td></tr></tbody></table></figure><h4 id="案例：通过压缩包导出导入镜像"><a href="#案例：通过压缩包导出导入镜像" class="headerlink" title="案例：通过压缩包导出导入镜像"></a>案例：通过压缩包导出导入镜像</h4><p>需求：利用 docker save 将 nginx 镜像导出磁盘，然后再通过 load 加载回来</p><p>1、利用 docker xx –help 命令查看 docker save 和 docker load 的语法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --help</span><br></pre></td></tr></tbody></table></figure><p>通过帮助文档可得知 save 的命令格式为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></tbody></table></figure><p>2、使用 docker save 导出镜像到磁盘</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></tbody></table></figure><p><code>-o</code> 表示选项，注意此时镜像在本地还是有的</p><p>3、使用 docker load 加载镜像</p><p>3.1）先删除本地的 nginx 镜像</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></tbody></table></figure><p>3.2）加载压缩包镜像</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></tbody></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><h4 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h4><p><img data-src="https://s2.loli.net/2023/01/12/IVYrTOqAgRfZQwM.png" alt="11-容器常用指令.png"></p><p>容器有三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU 不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU 等资源</li></ul><p>容器操作的命令：</p><ul><li>docker run：创建并运行一个容器，处于运行状态</li><li> docker pause：让一个运行的容器暂停</li><li> docker unpause：让一个容器从暂停状态恢复运行</li><li> docker stop：停止一个运行的容器</li><li> docker start：让一个停止的容器再次运行</li><li> docker rm：删除一个容器</li><li> docker ps：查看所有运行的容器及状态</li><li> docker logs：查看容器运行日志</li><li> docker exec：进入容器执行命令</li></ul><h4 id="案例：创建运行一个容器"><a href="#案例：创建运行一个容器" class="headerlink" title="案例：创建运行一个容器"></a>案例：创建运行一个容器</h4><p>需求：创建并运行 nginx 容器的命令</p><p>可以去官网搜索 Nginx，并查看其文档：<a href="https://hub.docker.com/_/nginx">nginx - Official Image | Docker Hub</a>，比如官网中给了如下运行命令示例：</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -d -p 8080:80 some-content-nginx</span><br></pre></td></tr></tbody></table></figure><p>这里以如下命令进行命令解读：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p <span class="number">80</span>:<span class="number">80</span> -d nginx</span><br></pre></td></tr></tbody></table></figure><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做 mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口；此处宿主机端口不做要求，但容器端口基本上取决于容器本身（软件监听的端口可能就是某一个端口）</li><li>-d：后台运行容器</li><li> nginx：镜像名称，例如 nginx，没有写标签 tag 说明是最新版 latest</li></ul><p>![[Pasted image 20230110202450.png]]</p><p>因为容器是隔离的，所以用户无法直接通过 80 端口来访问到容器，需要将容器的端口与宿主机端口映射。端口映射就相当于将原本隔离的容器暴露出一个小窗口，通过这个小窗口来对容器进行访问</p><p>容器创建完成后，会生成一个唯一 ID</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mn -p 80:80 -d nginx</span><br><span class="line">b8ae9bcbdde97a1ef9b055e44470427cd937571c4f2fdb5cb7a710c3d9a828e7</span><br></pre></td></tr></tbody></table></figure><p>通过访问宿主机 80 端口，就可访问 docker 中的 Nginx 服务了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.119</span><span class="number">.128</span>:<span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><p>通过 logs 命令可以查看容器日志</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令格式</span></span><br><span class="line">docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line"><span class="comment">//docker logs 容器名</span></span><br><span class="line">docker logs mn</span><br><span class="line"></span><br><span class="line"><span class="comment">//持续跟踪日志，通过Ctrl+C可以停止跟踪</span></span><br><span class="line">docker logs -f mn</span><br></pre></td></tr></tbody></table></figure><h4 id="案例：操作容器"><a href="#案例：操作容器" class="headerlink" title="案例：操作容器"></a>案例：操作容器</h4><p>需求：进入 Nginx 容器，修改 HTML 文件内容，添加 “coffeelize 欢迎您”</p><p>1、进入容器（容器是运行的）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mn bash</span><br></pre></td></tr></tbody></table></figure><p>命令解读：</p><ul><li>docker exec ：进入容器内部，执行一个命令</li><li> -it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li><li> mn ：要进入的容器的名称</li><li> bash：进入容器后执行的命令，bash 是一个 linux 终端交互命令</li></ul><p>注意：exec 命令可以进入容器修改文件，但是在容器内修改文件是不推荐的，修改了是没有记录（日志的），之后都不知道进行了哪些修改操作</p><p>2、进入 nginx 的 HTML 所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 linux 服务器一样</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@b8ae9bcbdde9:/# ls</span><br><span class="line">bin   dev                  docker-entrypoint.sh  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  docker-entrypoint.d  etc                   lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></tbody></table></figure><p>我们进入 Nginx 的目录（至于如何找到这个目录的可能需要在 DockerHub 查看 Nginx 的文档了），可以发现目录下包含 index.html</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/nginx/html</span><br></pre></td></tr></tbody></table></figure><p>3、修改 index.html 的内容</p><p>容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e 's#Welcome to nginx#coffeelize欢迎您#g' -e 's#&lt;head&gt;#&lt;head&gt;&lt;meta charset="utf-8"&gt;#g' index.html</span><br></pre></td></tr></tbody></table></figure><p>4、验证</p><p>访问虚拟机 80 端口，输出页面如下，说明修改成功</p><p><img data-src="https://s2.loli.net/2023/01/12/KebjRo19TSWsu5G.png" alt="12-修改成功.png"></p><p>5、退出容器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></tbody></table></figure><p>6、停止容器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker stop mn</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看运行中的docker</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment">//查看所有容器（包括停止的）</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></tbody></table></figure><p>7、启动容器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start mn</span><br></pre></td></tr></tbody></table></figure><p>8、删除容器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//停掉容器之后删除容器 或者 强制删除运行中的程序</span></span><br><span class="line">docker rm -f mn</span><br></pre></td></tr></tbody></table></figure><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>在之前的 nginx 案例中，修改 nginx 的 html 页面时，需要进入 nginx 内部。并且因为没有编辑器，修改文件也很麻烦，这就是因为容器与数据（容器内文件）耦合带来的后果。要解决这个问题，必须将 <strong>数据与容器解耦</strong>，这就要用到数据卷了</p><p><img data-src="https://s2.loli.net/2023/01/12/qvaxbfgRC5roE46.png" alt="13-容器与数据耦合度高.png"></p><p>数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录</p><p><img data-src="https://s2.loli.net/2023/01/12/fhdDyKUG9XLoEA5.png" alt="14-数据卷示意图.png"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了，这样，我们操作宿主机的 /var/lib/docker/volumes/html 目录，就等于操作容器内的 /usr/share/nginx/html 目录了；多个容器可以挂在同一个卷，就可以 “共享” 修改操作了；如果哪一天将容器删除了，没关系，数据卷还在，将新容器在挂载到这个数据卷上就可以了访问之前的数据了</p><h4 id="数据卷操作命令"><a href="#数据卷操作命令" class="headerlink" title="数据卷操作命令"></a>数据卷操作命令</h4><p>数据卷操作的基本语法如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></tbody></table></figure><ul><li>create：创建一个 volume</li><li>inspect：显示一个或多个 volume 的信息</li><li> ls：列出所有的 volume</li><li>prune：删除未使用的 volume</li><li>rm：删除一个或多个指定的 volume</li></ul><h4 id="案例：创建和查看数据卷"><a href="#案例：创建和查看数据卷" class="headerlink" title="案例：创建和查看数据卷"></a>案例：创建和查看数据卷</h4><p>需求：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>1、创建数据卷</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></tbody></table></figure><p>2、查看所有数据卷</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></tbody></table></figure><p>3、查看数据卷详细信息卷</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></tbody></table></figure><p>返回信息如下，其中重点关注 <strong>Mountpoint</strong> 挂载点</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker volume inspect html</span><br><span class="line">[</span><br><span class="line">    {</span><br><span class="line">        "CreatedAt": "2023-01-10T21:32:34+08:00",</span><br><span class="line">        "Driver": "local",</span><br><span class="line">        "Labels": {},</span><br><span class="line">        "Mountpoint": "/var/lib/docker/volumes/html/_data",</span><br><span class="line">        "Name": "html",</span><br><span class="line">        "Options": {},</span><br><span class="line">        "Scope": "local"</span><br><span class="line">    }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>4、小结</p><p>数据卷的作用：将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</p><h4 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h4><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></tbody></table></figure><p>这里的 -v 就是挂载数据卷的命令：</p><ul><li><code>docker run</code>：创建并运行容器</li><li><code>--name mn</code>：给容器起个名字叫 mn</li><li><code>-v html:/root/html</code> ：把 html 数据卷挂载到容器内的 /root/html 这个目录中</li><li><code>-p 8080:80</code>：吧宿主机的 8080 端口映射到容器内的 80 端口</li><li> nginx：镜像名称</li></ul><h4 id="案例：给-nginx-挂载数据卷"><a href="#案例：给-nginx-挂载数据卷" class="headerlink" title="案例：给 nginx 挂载数据卷"></a>案例：给 nginx 挂载数据卷</h4><p>需求：创建一个 nginx 容器，修改容器内的 html 目录内的 index.html 内容<br>分析：上个案例中，我们进入 nginx 容器内部，已经知道 nginx 的 html 目录所在位置 /usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容</p><p>0、查看容器是否在运行，并且已经提前创建好了 html 数据卷</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查容器是否在运行</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></tbody></table></figure><p>1、创建容器并挂载数据卷到容器内的 HTML 目录</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p <span class="number">80</span>:<span class="number">80</span> -d nginx</span><br></pre></td></tr></tbody></table></figure><p>2、进入 html 数据卷所在位置，并修改 HTML 内容</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 通过查看挂载点可知如下目录，进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 查看目录下有哪些文件</span></span><br><span class="line">ls</span><br><span class="line"><span class="comment"># 修改文件，此处可通过FinalShell使用本地的高级编辑工具来打开编辑</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></tbody></table></figure><p>3、在做数据卷挂在时，如果要创建数据卷不存在，docker 会为我们自动创建数据卷</p><p>比如在我们使用如下命令前，docker 中是没有 html 数据卷的，一样可以正常使用如下命令，因为 docker 会为我们自动创建 html 数据卷</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p <span class="number">80</span>:<span class="number">80</span> -d nginx</span><br></pre></td></tr></tbody></table></figure><h4 id="案例：给-MySQL-挂载本地目录"><a href="#案例：给-MySQL-挂载本地目录" class="headerlink" title="案例：给 MySQL 挂载本地目录"></a>案例：给 MySQL 挂载本地目录</h4><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 –&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 –&gt; 容器内目录</li></ul><p><img data-src="https://s2.loli.net/2023/01/12/VtnMporfXRlwxDS.png" alt="15-容器直接挂在到宿主机.png"></p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li><code>-v [宿主机目录]:[容器内目录]</code></li><li><code>-v [宿主机文件]:[容器内文件]</code></li></ul><p>案例需求：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器</p><p>1、将课前资料中的 mysql.tar 文件上传到虚拟机的 tmp 目录，通过 load 命令加载为镜像</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">cd tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment">//rz或FinalShell上传mysql.tar</span></span><br><span class="line"></span><br><span class="line">docker load -i mysql.tar</span><br><span class="line"><span class="comment">//查看镜像是否导入，mysql的版本为5.7.25</span></span><br><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure><p>2、创建目录 /tmp/mysql/data</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-p表示多级目录创建</span></span><br><span class="line">mkdir -p /tmp/mysql/data</span><br></pre></td></tr></tbody></table></figure><p>3、创建目录 /tmp/mysql/conf，将课前资料提供的 hmy.cnf 文件上传到 /tmp/mysql/conf</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-p表示多级目录创建</span></span><br><span class="line">mkdir -p /tmp/mysql/conf</span><br><span class="line"></span><br><span class="line"><span class="comment">//rz或FinalShell上传hmy.cnf</span></span><br></pre></td></tr></tbody></table></figure><p>hmy.cnf 的文件内容为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">character_set_server=utf8</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">server-id=1000</span><br></pre></td></tr></tbody></table></figure><p>4、去 DockerHub 查阅资料 <a href="https://hub.docker.com/_/mysql">mysql | Docker Hub</a>，创建并运行 MySQL 容器，要求：</p><p>1）挂载 /tmp/mysql/data 到 mysql 容器内数据存储目录<br>2）挂载 /tmp/mysql/conf/hmy.cnf 到 mysql 容器的配置文件<br>3）设置 MySQL 密码</p><p>官网上给定的运行示例如下</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br></pre></td></tr></tbody></table></figure><p>其中 -e 表示运行环境，后面可以直接设置 mysql 密码；-d 表示后台运行；tag 为版本号，其中还缺少了端口号的设置，我们对这个命令进行修改</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> --name mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line"> -p 3306:3306 \</span><br><span class="line"> -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \</span><br><span class="line"> -v /tmp/mysql/data:/var/lib/mysql \</span><br><span class="line"> -d \</span><br><span class="line"> mysql:5.7.25</span><br></pre></td></tr></tbody></table></figure><p>但是此时有个报错 (bind: address already in use)，因为之前我们已经在虚拟机中运行 MySQL 了，也就是已经占用了宿主机的 3306 端口，这里我们改成 3305 试一下</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//删除刚才创建的mysql容器</span><br><span class="line">docker rm mysql</span><br><span class="line"></span><br><span class="line">//再次执行如下命令，注意端口改为了3305</span><br><span class="line">docker run \</span><br><span class="line"> --name mysql \</span><br><span class="line"> -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line"> -p 3305:3306 \</span><br><span class="line"> -v /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf \</span><br><span class="line"> -v /tmp/mysql/data:/var/lib/mysql \</span><br><span class="line"> -d \</span><br><span class="line"> mysql:5.7.25</span><br></pre></td></tr></tbody></table></figure><p>注意：此处的 /etc/mysql/conf.d 目录，可以合并添加我们创建的 hmy.cnf 配置，而不是将 MySQL 默认的配置文件完全覆盖掉（因为我们创建的配置文件只包含了默认配置的少数配置信息，替换掉默认配置的话配置就不全了）</p><p>5、测试 MySQL 连接</p><p>通过 Navicat 测试可正常连接<br><img data-src="https://s2.loli.net/2023/01/12/yt4LbEZ8NBzwWiV.png" alt="16-Navicat连接成功.png"></p><p>6、小节</p><p>数据卷挂载与目录直接挂载的比较：</p><ul><li>数据卷挂载耦合度低，由 docker 来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><h2 id="Dockerfile-自定义镜像"><a href="#Dockerfile-自定义镜像" class="headerlink" title="Dockerfile 自定义镜像"></a>Dockerfile 自定义镜像</h2><h3 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h3><p>常见的镜像在 DockerHub 就能找到，但是我们自己写的项目就必须自己构建镜像了，而要自定义镜像，就必须先了解镜像的结构才行</p><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。我们以 MySQL 为例，来看看镜像的组成结构</p><p><img data-src="https://s2.loli.net/2023/01/12/tvRsDH1aQjO7zxf.png" alt="17-镜像结构.png"></p><ul><li>基础镜像（BaseImage）：应用依赖的系统函数库、环境、配置、文件等</li><li>入口（Entrypoint）：镜像运行入口，一般是程序启动的脚本和参数</li><li>层（Layer）：在 BaseImage 基础上添加安装包、依赖、配置等，每次操作都形成新的层</li></ul><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile 是一个文本文件，其中包含一个个的 ** 指令 (Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。更新详细语法说明，可参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><p><img data-src="https://s2.loli.net/2023/01/12/h34vkV1QpgUNIXs.png" alt="18-Dockerfile指令.png"></p><h3 id="构建-Java-项目"><a href="#构建-Java-项目" class="headerlink" title="构建 Java 项目"></a>构建 Java 项目</h3><h4 id="基于-Ubuntu-构建-Java-项目"><a href="#基于-Ubuntu-构建-Java-项目" class="headerlink" title="基于 Ubuntu 构建 Java 项目"></a>基于 Ubuntu 构建 Java 项目</h4><p>需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 java 项目</p><p>1、新建一个空文件夹 docker-demo</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp/</span><br><span class="line">mkdir docker-demo</span><br></pre></td></tr></tbody></table></figure><p>2、拷贝课前资料中的 docker-demo.jar 文件到 docker-demo 这个目录<br>3、拷贝课前资料中的 jdk8.tar.gz 文件到 docker-demo 这个目录<br>4、拷贝课前资料提供的 Dockerfile 到 docker-demo 这个目录</p><p>Dockerfile 中的内容如下</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></tbody></table></figure><p>5、进入 docker-demo</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd docker-demo</span><br></pre></td></tr></tbody></table></figure><p>6、运行命令</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:<span class="number">1.0</span> .</span><br></pre></td></tr></tbody></table></figure><p>-t 表示 tag；javaweb 为镜像名称；注意命令后面还有个 <code>.</code>，表示 dockerfile 所在的目录（构建时告知 dockerfile 在哪）</p><p>可以看到 dockerfile 共有 9 个指令，也就分为了 9 个 step，每个指令执行都会创建出一个层</p><p>7、通过命令查看构建好的镜像</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker-demo]# docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">javaweb      1.0       c94aff541e94   42 seconds ago   722MB</span><br><span class="line">nginx        latest    605c77e624dd   12 months ago    141MB</span><br><span class="line">redis        latest    7614ae9453d1   12 months ago    113MB</span><br><span class="line">ubuntu       16.04     b6f507652425   16 months ago    135MB</span><br><span class="line">mysql        5.7.25    98455b9624a9   3 years ago      372MB</span><br></pre></td></tr></tbody></table></figure><p>可以看到我们基于 ubuntu 构建的（配置好 java 环境的）javaweb 项目的镜像已经构建好了</p><p>可以通过命令来运行镜像（8090 端口在 dockerfile 中已经声明暴露了端口）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web -p <span class="number">8090</span>:<span class="number">8090</span> -d javaweb:<span class="number">1.0</span></span><br></pre></td></tr></tbody></table></figure><p>浏览器访问如下地址，可以发现我们的项目（之前我们的 docker-demo.jar 项目）正常跑起来了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//192.168.119.128:8090/hello/count</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/01/12/zxFcQYWgAJBME8f.png" alt="19-项目运行成功.png"></p><p>虚拟机中运行 docker –&gt; docker 中运行 ubuntu –&gt; ubuntu 中运行 docker-demo java 项目😂，虚拟机内存开始吃紧了</p><p><img data-src="https://s2.loli.net/2023/01/12/aT5AVJ8nsC7po9g.png" alt="20-虚拟机内存吃紧.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>分析：其实我们的 java 项目真正只用到了如下一行</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span></span><br></pre></td></tr></tbody></table></figure><p>dockerfile 文件内容：</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></tbody></table></figure><p>那么我们之后在构建 Java 项目镜像时，可以先构建如下不会改变的层做一个镜像，然后在基于这个镜像来构建。</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></tbody></table></figure><p>而实际上，有人也已经构建好了这个镜像了，我们直接拿来用就行，镜像名为 java:8-alpine</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="comment"># 拷贝java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></tbody></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>Docker Compose 可以基于 Compose 文件帮我们快速部署分布式应用，而无需手动一个个创建和运行容器</p><h3 id="初识-DockerCompose"><a href="#初识-DockerCompose" class="headerlink" title="初识 DockerCompose"></a>初识 DockerCompose</h3><p>Compose 文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下（相当于把 docker run 中的所有指令转换为了 Compose 指令了）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version:&nbsp;<span class="string">"3.8"</span></span><br><span class="line">services:</span><br><span class="line">&nbsp;&nbsp;mysql:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;image:&nbsp;mysql:<span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: <span class="number">123</span> </span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;volumes:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="string">"/tmp/mysql/data:/var/lib/mysql"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="string">"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf"</span></span><br><span class="line">&nbsp;&nbsp;web:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;build:&nbsp;.</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;ports:</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="string">"8090:8090"</span></span><br></pre></td></tr></tbody></table></figure><p>上面的 Compose 文件就描述一个项目，其中包含两个容器</p><ul><li>mysql：一个基于 <code>mysql:5.7.25</code> 镜像构建的容器，并且挂载了两个目录<ul><li>为什么没有定义端口呢：因为 MySQL 运行在微服务当中，供内部使用无需对外开放</li><li>无需定义后台运行，默认就是后台运行</li></ul></li><li> web：一个基于 <code>docker build</code> 临时构建的镜像容器，映射端口时 8090<ul><li> 为什么没有指定镜像：因为通过 build 就可以构建镜像</li></ul></li></ul><h3 id="安装-DockerCompose"><a href="#安装-DockerCompose" class="headerlink" title="安装 DockerCompose"></a>安装 DockerCompose</h3><p>1、下载</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">curl -L https:<span class="comment">//github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span></span><br></pre></td></tr></tbody></table></figure><p>或者通过本地文件准备好的文件直接上传，上传至 <code>/usr/local/bin/</code> 目录</p><p>2、修改文件权限</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></tbody></table></figure><p>3、Base 自动补全命令</p><p>之后使用 Docker Compose 时就会有补全提示</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 补全命令</span><br><span class="line">curl -L https:<span class="comment">//raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span></span><br></pre></td></tr></tbody></table></figure><p>此时可能会报：拒绝连接的错误，需要执行如下命令修改 hosts 文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"199.232.68.133 raw.githubusercontent.com"</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></tbody></table></figure><h4 id="案例：利用-DockerCompose-部署"><a href="#案例：利用-DockerCompose-部署" class="headerlink" title="案例：利用 DockerCompose 部署"></a>案例：利用 DockerCompose 部署</h4><p>需求：将之前学习的 cloud-demo 微服务集群利用 DockerCompose 部署</p><p>1、查看课前资料提供的 cloud-demo 文件夹，里面已经编写好了 docker-compose 文件</p><p>课前资料提供的 cloud-demo 文件夹，里面已经编写好了 docker-compose 文件，而且每个微服务都准备了一个独立的目录。对于每一个微服务目录，其中都包含一个 Dockerfile 文件和对于的微服务 jar 包。最外层包含 docker-compose.yml 配置文件，文件内容如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">"3.2"</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nacos:</span><br><span class="line">    image: nacos/nacos-server</span><br><span class="line">    environment:</span><br><span class="line">      MODE: standalone</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"8848:8848"</span></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:<span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: <span class="number">123</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">"$PWD/mysql/data:/var/lib/mysql"</span></span><br><span class="line">      - <span class="string">"$PWD/mysql/conf:/etc/mysql/conf.d/"</span></span><br><span class="line">  userservice:</span><br><span class="line">    build: ./user-service</span><br><span class="line">  orderservice:</span><br><span class="line">    build: ./order-service</span><br><span class="line">  gateway:</span><br><span class="line">    build: ./gateway</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"10010:10010"</span></span><br></pre></td></tr></tbody></table></figure><p>这几个微服务（mysql、userservice、orderservice 以及 gateway）中，只有网关暴露了端口，因为网关是外部访问微服务的入口。其他微服务都需要注册到 Nacos 服务中</p><p>MySQL 微服务中需要的表和数据课程资料也已经为我们准备好了</p><p>2、修改自己的 cloud-demo 项目，将数据库、nacos 地址都命名为 docker-compose 中的服务名</p><p>因为微服务将来要部署为 docker 容器，而容器之间互联不是通过 IP 地址，而是通过容器名。这里我们将 order-service、user-service、gateway 服务的 mysql、nacos 地址都修改为基于容器名的访问</p><p>比如 user-service 中的 bootstrap 配置文件</p><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  application:  </span><br><span class="line">    name: userservice # 服务名称  </span><br><span class="line">  profiles:  </span><br><span class="line">    active: dev #开发环境，这里是dev  </span><br><span class="line">  cloud:  </span><br><span class="line">    nacos:  </span><br><span class="line"><span class="deletion">-     server-addr: localhost:8848 # Nacos地址  </span></span><br><span class="line"><span class="addition">+     server-addr: nacos:8848 # Nacos地址  </span></span><br><span class="line">      config:  </span><br><span class="line">        file-extension: yaml # 文件后缀名</span><br></pre></td></tr></tbody></table></figure><p>application.yml 配置文件中</p><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- url: jdbc:mysql://localhost:3306/cloud_user?useSSL=false</span></span><br><span class="line"><span class="addition">+ url: jdbc:mysql://mysql:3306/cloud_user?useSSL=false</span></span><br></pre></td></tr></tbody></table></figure><p>同理，order-service 和 gateway 微服务的配置文件也这样修改</p><p>3、使用 maven 打包工具，将项目中的每个微服务都打包为 app.jar</p><p>为什么都打包成 app.jar 呢 –&gt; 因为我们在微服务目录下的 Dockerfile 文件里是这样配置的，我们配置的名称都是 app.jar</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM java:<span class="number">8</span>-alpine</span><br><span class="line">COPY ./app.jar /tmp/app.jar</span><br><span class="line">ENTRYPOINT java -jar /tmp/app.jar</span><br></pre></td></tr></tbody></table></figure><p>那么，既然各个微服务打包完成都需要叫这个 app.jar 名字，我们是否可以修改配置文件实现项目打包自动叫这个名字呢 –&gt; 可以的，在各个微服务的 pom 文件中添加如下配置</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>app<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>通过 Maven 的 Package 来打包</p><p>4、将打包好的 app.jar 拷贝到 cloud-demo 中的每一个对应的微服务子目录中</p><p><img data-src="https://s2.loli.net/2023/01/12/UBkKv8HJ3dL9gNj.gif" alt="21-项目部署前准备.gif"></p><p>5、将 cloud-demo 上传至虚拟机 (tmp 目录)，利用 docker-compose up -d 来部署</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">cd /tmp/</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传cloud-demo文件夹</span></span><br><span class="line"></span><br><span class="line">cd cloud-demo/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></tbody></table></figure><ul><li>up：表示创建并执行容器</li><li> down：停止并删除容器</li><li>其他命令可以通过 help 命令查看</li></ul><p>6、查看打包好的镜像和运行的容器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker ps</span><br></pre></td></tr></tbody></table></figure><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cloud-demo]# docker images</span><br><span class="line">REPOSITORY                TAG        IMAGE ID       CREATED              SIZE</span><br><span class="line">cloud-demo_gateway        latest     3ce691e26939   About a minute ago   185MB</span><br><span class="line">cloud-demo_orderservice   latest     b81195944331   About a minute ago   187MB</span><br><span class="line">cloud-demo_userservice    latest     2dc6d8c88bdc   About a minute ago   184MB</span><br><span class="line">javaweb                   1.0        c94aff541e94   3 hours ago          722MB</span><br><span class="line">nginx                     latest     605c77e624dd   12 months ago        141MB</span><br><span class="line">redis                     latest     7614ae9453d1   12 months ago        113MB</span><br><span class="line">ubuntu                    16.04      b6f507652425   16 months ago        135MB</span><br><span class="line">nacos/nacos-server        latest     bdf60dc2ada3   17 months ago        1.05GB</span><br><span class="line">mysql                     5.7.25     98455b9624a9   3 years ago          372MB</span><br><span class="line">java                      8-alpine   3fd9dd82815c   5 years ago          145MB</span><br></pre></td></tr></tbody></table></figure><p>虚拟机 2G 内存快要炸了😳，开始借用交换内存了</p><p>7、通过查看日志可发现 order-service 有报错</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出日志</span></span><br><span class="line">Ctrl+C</span><br><span class="line"></span><br><span class="line"><span class="comment">//重启微服务(微服务启动前Nacos已经启动完成)</span></span><br><span class="line">docker-compose restart gateway userservice orderservice</span><br></pre></td></tr></tbody></table></figure><p>原因是因为 Nacos 微服务启动晚于 order-service，导致报错。关键是报错之后没有进行重新启动 –&gt; 因此，我们最好是先启动 Nacos 微服务，之后再启动 order-service 等系列微服务</p><p>浏览器访问如下，均可正常接收到数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//192.168.119.128:10010/user/2?authorization=admin</span></span><br><span class="line">http:<span class="comment">//192.168.119.128:10010/order/102?authorization=admin</span></span><br></pre></td></tr></tbody></table></figure><p>至此，DockerCompose 部署微服务完成</p><p>8、删除掉这些容器吧，虚拟机要炸了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除通过docker-compose部署的容器，同时删除镜像</span></span><br><span class="line">docker-compose down --rmi all</span><br></pre></td></tr></tbody></table></figure><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cloud-demo]# docker-compose down --rmi all</span><br><span class="line">Stopping cloud-demo_nacos_1        ... done</span><br><span class="line">Stopping cloud-demo_userservice_1  ... done</span><br><span class="line">Stopping cloud-demo_gateway_1      ... done</span><br><span class="line">Stopping cloud-demo_mysql_1        ... done</span><br><span class="line">Stopping cloud-demo_orderservice_1 ... done</span><br><span class="line">Removing cloud-demo_nacos_1        ... done</span><br><span class="line">Removing cloud-demo_userservice_1  ... done</span><br><span class="line">Removing cloud-demo_gateway_1      ... done</span><br><span class="line">Removing cloud-demo_mysql_1        ... done</span><br><span class="line">Removing cloud-demo_orderservice_1 ... done</span><br><span class="line">Removing network cloud-demo_default</span><br><span class="line">Removing image nacos/nacos-server</span><br><span class="line">Removing image mysql:5.7.25</span><br><span class="line">Removing image cloud-demo_userservice</span><br><span class="line">Removing image cloud-demo_orderservice</span><br><span class="line">Removing image cloud-demo_gateway</span><br></pre></td></tr></tbody></table></figure><h2 id="Docker-镜像仓库"><a href="#Docker-镜像仓库" class="headerlink" title="Docker 镜像仓库"></a>Docker 镜像仓库</h2><h3 id="简化版镜像仓库"><a href="#简化版镜像仓库" class="headerlink" title="简化版镜像仓库"></a>简化版镜像仓库</h3><p>Docker 官方的 Docker Registry 是一个基础版本的 Docker 镜像仓库，具备仓库管理的完整功能，但是没有图形化界面</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></tbody></table></figure><p>命令中挂载了一个数据卷 registry-data 到容器内的 /var/lib/registry 目录，这是私有镜像库存放数据的目录，访问如下链接可以查看当前私有镜像服务中包含的镜像</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://yourip:5000/v2/_catalog</span><br></pre></td></tr></tbody></table></figure><h3 id="带有图形化界面版本"><a href="#带有图形化界面版本" class="headerlink" title="带有图形化界面版本"></a>带有图形化界面版本</h3><p>操作此步骤前，需要先完成 Docker 信任地址配置</p><p>使用 DockerCompose 部署带有图象界面的 DockerRegistry，命令如下</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">mkdir registry-ui</span><br><span class="line"><span class="built_in">cd</span> registry-ui</span><br><span class="line">touch docker-compose.yml</span><br><span class="line">//修改这个yml文件，内容如下代码块</span><br><span class="line"></span><br><span class="line">//修改yml文件完成后执行docker-compose</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.0'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=coffeelize私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></tbody></table></figure><p>通过访问如下地址，即可访问我们创建的带有图形界面的 Docker 镜像仓库了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.119</span><span class="number">.128</span>:<span class="number">8080</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/01/12/SwRi8jDgNpnaeBW.png" alt="22-建立私有仓库.png"></p><h3 id="配置-Docker-信任地址"><a href="#配置-Docker-信任地址" class="headerlink" title="配置 Docker 信任地址"></a>配置 Docker 信任地址</h3><p>我们的私服采用的是 http 协议，默认不被 Docker 信任，所以需要做一个配置</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">"insecure-registries"</span>:[<span class="string">"http://192.168.119.128:8080"</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></tbody></table></figure><p>在添加内容时，注意多个配置之间别把逗号忘加了</p><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "registry-mirrors": ["https://5vycoa8o.mirror.aliyuncs.com"],</span><br><span class="line"><span class="addition">+ "insecure-registries":["http://192.168.119.128:8080"]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="在私有镜像仓库中推送或拉去镜像"><a href="#在私有镜像仓库中推送或拉去镜像" class="headerlink" title="在私有镜像仓库中推送或拉去镜像"></a>在私有镜像仓库中推送或拉去镜像</h3><p>推送镜像到私有镜像服务必须先 tag，步骤如下：</p><p>1、重新 tag 本地镜像（重命名镜像，并且以镜像仓库地址为前缀），名称前缀为私有仓库的地址：192.168.119.128:8080/</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.119.128:8080/nginx:1.0 </span><br></pre></td></tr></tbody></table></figure><p>利用 tag 命令，可以将一个镜像重命名，这里我们对之前下载的最新版 Nginx 镜像进行操作</p><p><img data-src="https://s2.loli.net/2023/01/12/fAnQie3o84j2UsK.png" alt="23-推送镜像前重命名镜像.png"></p><p>此时，查看本地的镜像，就可以找到我们打包并且重命名后的镜像了，可以发现这两个镜像的 ID（605c77e624dd）其实是一样的</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.168.119.128:8080/nginx   1.0        605c77e624dd   12 months ago   141MB</span><br><span class="line">nginx                        latest     605c77e624dd   12 months ago   141MB</span><br></pre></td></tr></tbody></table></figure><p>2、推送镜像</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.119.128:8080/nginx:1.0 </span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2023/01/12/hyPA2ptnv3GEFlj.png" alt="24-推送镜像到私有仓库.png"></p><p>3、拉取镜像</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.150.101:8080/nginx:1.0 </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前置知识：SpringCloud&lt;/p&gt;
&lt;h2 id=&quot;初识-Docker&quot;&gt;&lt;a href=&quot;#初识-Docker&quot; class=&quot;headerlink&quot; title=&quot;初识 Docker&quot;&gt;&lt;/a&gt;初识 Docker&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="https://coffeelize.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>单元测试 &amp; 日志简明笔记</title>
    <link href="https://coffeelize.top/posts/a306b413.html"/>
    <id>https://coffeelize.top/posts/a306b413.html</id>
    <published>2022-12-21T09:32:30.000Z</published>
    <updated>2022-12-23T04:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>JUnit 是一个 Java 编程语言的单元测试工具。JUnit 是一个非常重要的测试工具</p><p>JUnit 在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色</p><span id="more"></span><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>将 junit 的 jar 包导入到工程中 junit-4.9.jar</li><li> 编写测试方法该测试方法必须是公共的无参数无返回值的非静态方法</li><li>在测试方法上使用 @Test 注解标注该方法是一个测试方法</li><li>选中测试方法右键通过 junit 运行该方法</li></ol><p>代码示例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitDemo1</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="number">2</span> / <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = a + b;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h3><ul><li>@Test：表示测试该方法</li><li> @Before：在测试的方法前运行</li><li> @After：在测试的方法后运行</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>程序中的日志可以用来记录程序在运行的时候点点滴滴，并可以进行永久存储</p><p>日志与输出语句的区别</p><table><thead><tr><th></th><th>输出语句</th><th>日志技术</th></tr></thead><tbody><tr><td>取消日志</td><td>需要修改代码，灵活性比较差</td><td>不需要修改代码，灵活性比较好</td></tr><tr><td>输出位置</td><td>只能是控制台</td><td>可以将日志信息写入到文件或者数据库中</td></tr><tr><td>多线程</td><td>和业务代码处于一个线程中</td><td>多线程方式记录日志，不影响业务代码的性能</td></tr></tbody></table><h3 id="日志体系结构"><a href="#日志体系结构" class="headerlink" title="日志体系结构"></a>日志体系结构</h3><p><img data-src="https://s2.loli.net/2022/12/21/AHZCuKrhD3FgW87.png" alt="01-日志的体系结构.png"></p><h3 id="Log4J"><a href="#Log4J" class="headerlink" title="Log4J"></a>Log4J</h3><p>Log4j 是 Apache 的一个开源项目；通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件等位置，我们也可以控制每一条日志的输出格式，通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程</p><p>最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码</p><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><ol><li>导入 log4j 的相关 jar 包</li><li>编写 log4j 配置文件</li><li>在代码中获取日志的对象</li><li>按照级别设置记录日志信息</li></ol><h4 id="1、properties-文件"><a href="#1、properties-文件" class="headerlink" title="1、properties 文件"></a>1、properties 文件</h4><p>注意：配置文件的文件名必须是 <code>log4j.properties</code>，放在 src 目录下</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">//</span> <span class="string">log4j的配置文件,名字为log4j.properties, 放在src根目录下</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug,my,fileAppender</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### direct log messages to my ###</span></span><br><span class="line"><span class="meta">log4j.appender.my</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.my.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.my.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.my.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.my.layout.ConversionPattern</span>=<span class="string">%d %t %5p %c{1}:%L - %m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># fileAppender演示</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.File</span>=<span class="string">D:/log4j-log.log</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.layout.ConversionPattern</span>=<span class="string">%d %5p %c{1}:%L - %m%n</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2、测试类"><a href="#2、测试类" class="headerlink" title="2、测试类"></a>2、测试类</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4JTest01</span> </span>{</span><br><span class="line">    <span class="comment">//方式1：使用log4j的api来获取日志的对象</span></span><br><span class="line">    <span class="comment">//弊端：如果以后我们更换日志的实现类，那么下面的代码就需要跟着改</span></span><br><span class="line">    <span class="comment">//不推荐使用</span></span><br><span class="line">    <span class="comment">//private static final Logger LOGGER = Logger.getLogger(Log4JTest01.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2：使用slf4j里面的api来获取日志的对象</span></span><br><span class="line">    <span class="comment">//好处：如果以后我们更换日志的实现类，那么下面的代码不需要跟着修改</span></span><br><span class="line">    <span class="comment">//推荐使用（在代码中获取日志的对象）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Log4JTest01.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//1.导入jar包</span></span><br><span class="line">        <span class="comment">//2.编写配置文件</span></span><br><span class="line">        <span class="comment">//3.在代码中获取日志的对象</span></span><br><span class="line">        <span class="comment">//4.按照日志级别设置日志信息</span></span><br><span class="line">        LOGGER.debug(<span class="string">"debug级别的日志"</span>);</span><br><span class="line">        LOGGER.info(<span class="string">"info级别的日志"</span>);</span><br><span class="line">        LOGGER.warn(<span class="string">"warn级别的日志"</span>);</span><br><span class="line">        LOGGER.error(<span class="string">"error级别的日志"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h4><p>三个核心</p><ul><li>Loggers (记录器) ：日志的级别<ul><li> Loggers 组件在此系统中常见的五个级别：DEBUG、INFO、WARN、ERROR 和 FATAL</li><li>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</li><li>Log4j 有一个规则：只输出级别不低于设定级别的日志信息</li></ul></li><li> Appenders (输出源)：日志要输出的地方<ul><li>把日志输出到不同的地方，如控制台（Console）、文件（Files）等</li><li> org.apache.log4j.ConsoleAppender（控制台）</li><li>org.apache.log4j.FileAppender（文件）</li></ul></li><li>Layouts (布局)：日志输出的格式<ul><li> org.apache.log4j.PatternLayout（可以灵活地指定布局模式，这个比较常用）</li><li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li><li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</li></ul></li></ul><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">//</span> <span class="string">log4j的配置文件,名字为log4j.properties, 放在src根目录下</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug,my,fileAppender</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### direct log messages to my ###</span></span><br><span class="line"><span class="meta">log4j.appender.my</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.my.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.my.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.my.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.my.layout.ConversionPattern</span>=<span class="string">%d %t %5p %c{1}:%L - %m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># fileAppender演示</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.File</span>=<span class="string">D:/log4j-log.log</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.layout.ConversionPattern</span>=<span class="string">%d %5p %c{1}:%L - %m%n</span></span><br></pre></td></tr></tbody></table></figure><p>1、配置根 Logger</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">日志级别，appenderName1，appenderName2，…</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别</span></span><br><span class="line"><span class="comment"># appenderName1：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开</span></span><br></pre></td></tr></tbody></table></figure><p>2、ConsoleAppender 常用的选项</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.appender.my</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.my.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.my.Target</span>=<span class="string">System.out</span></span><br></pre></td></tr></tbody></table></figure><ul><li>第一句表示往控制台输出</li><li>第二句表示所有消息都会被立即输出，设为 false 则不输出，默认值是 true</li><li> 第三句默认值是 <code>System.out</code><ul><li>比如 <code>System.err</code> 打印出来是红色的</li></ul></li></ul><p>3、FileAppender 常用的选项</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.appender.fileAppender</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.ImmediateFlush</span> = <span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.Append</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">log4j.appender.fileAppender.File</span>=<span class="string">D:/log4j-log.log</span></span><br></pre></td></tr></tbody></table></figure><ul><li>第一句：往文件中输出</li><li>第二句：表示所有消息都会被立即输出。设为 false 则不输出，默认值是 true</li><li> 第三句：true 表示将消息添加到指定文件中，原来的消息不覆盖，默认值是 true</li><li> 第四句：指定消息输出到某个文件中</li></ul><p>4、PatternLayout 常用的选项</p><ul><li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式，最常用）</li><li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</li><li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</li></ul><p>这里我们只讲第一种：PatternLayout 的常用选项</p><p><img data-src="https://s2.loli.net/2022/12/21/c8e5sgo1wVO6LWk.png" alt="02-日志中PatternLayout的常用选项.png"></p><h3 id="在项目中的应用"><a href="#在项目中的应用" class="headerlink" title="在项目中的应用"></a>在项目中的应用</h3><ol><li>导入相关的依赖</li><li>将资料中的 properties 配置文件复制到 src 目录下</li><li>在代码中获取日志的对象</li><li>按照级别设置记录日志信息</li></ol><p>代码实现</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = "/servlet/loginservlet")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">implements</span> <span class="title">HttpServlet</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取日志的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LoginServlet.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpRequest httpRequest, HttpResponse httpResponse)</span> </span>{</span><br><span class="line">       <span class="comment">//处理</span></span><br><span class="line">        System.out.println(<span class="string">"LoginServlet处理了登录请求"</span>);</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"现在已经处理了登录请求，准备给浏览器响应"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//响应</span></span><br><span class="line">        httpResponse.setContentTpye(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        httpResponse.write(<span class="string">"登录成功"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：Logger 对象是 slf4j (org.slf4jh) 中的，不要导错包了</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;headerlink&quot; title=&quot;单元测试&quot;&gt;&lt;/a&gt;单元测试&lt;/h2&gt;&lt;p&gt;JUnit 是一个 Java 编程语言的单元测试工具。JUnit 是一个非常重要的测试工具&lt;/p&gt;
&lt;p&gt;JUnit 在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://coffeelize.top/tags/Java/"/>
    
    <category term="JUnit" scheme="https://coffeelize.top/tags/JUnit/"/>
    
    <category term="Log4J" scheme="https://coffeelize.top/tags/Log4J/"/>
    
  </entry>
  
  <entry>
    <title>反射简明笔记</title>
    <link href="https://coffeelize.top/posts/507300e0.html"/>
    <id>https://coffeelize.top/posts/507300e0.html</id>
    <published>2022-12-20T09:13:20.000Z</published>
    <updated>2023-08-02T01:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3><p>反射机制</p><ul><li>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意属性和方法；</li><li>这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。<span id="more"></span><img data-src="https://s2.loli.net/2022/12/21/qgzEGN9v8lxnTfB.png" alt="01-用子类创建对象与常规创建对象的比较.png"></li></ul><p>总结下来</p><ul><li>利用反射可以无视修饰符获取类里面所有的属性和方法</li><li>先获取配置文件中的信息，动态获取（如从配置文件中的读取）信息并创建对象和调用方法</li></ul><h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>调用一个类中的方法（如上图所示）</p><ol><li>创建这个类的对象</li><li>用对象调用方法</li></ol><p>反射去调用一个类中的方法（如上图所示）</p><ol><li>反射方式：创建对象</li><li>反射方式：调用方法<br><img data-src="https://s2.loli.net/2022/12/21/jBebitcPmFdsE1z.png" alt="02-利用反射调用类中的方法.png"></li></ol><p>那么现在的问题就是如何获取这个 Class 对象<br><img data-src="https://s2.loli.net/2022/12/21/kfwiNhrTy3elumV.png" alt="03-获取Class对象的三种方式.png"></p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"学生在学习"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="三种获取-Class-对象方式"><a href="#三种获取-Class-对象方式" class="headerlink" title="三种获取 Class 对象方式"></a>三种获取 Class 对象方式</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//1.Class类中的静态方法forName("全类名")</span></span><br><span class="line">        <span class="comment">//全类名:包名 + 类名</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect2.Student"</span>);</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过class属性来获取</span></span><br><span class="line">        Class clazz2 = Student.class;</span><br><span class="line">        System.out.println(clazz2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.利用对象的getClass方法来获取class对象</span></span><br><span class="line">        <span class="comment">//getClass方法是定义在Object类中.</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        Class clazz3 = s.getClass();</span><br><span class="line">        System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//class对象是唯一的</span></span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line">        System.out.println(clazz2 == clazz3);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反射获取-Class-类的对象"><a href="#反射获取-Class-类的对象" class="headerlink" title="反射获取 Class 类的对象"></a>反射获取 Class 类的对象</h3><p>Class 类的对象包括：成员变量对象、构造器对象及成员方法对象</p><p><img data-src="https://s2.loli.net/2022/12/21/ychfZ7kBYgdG9wb.png" alt="04-Class对象中的3类对象.png"></p><h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有的有参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"name的值为:"</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"private...Student...有参构造方法"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共的无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"public...Student...无参构造方法"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共的有参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"name的值为:"</span> + name + <span class="string">"age的值为:"</span> + age);</span><br><span class="line">        System.out.println(<span class="string">"public...Student...有参构造方法"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="获取-Constructor-对象"><a href="#获取-Constructor-对象" class="headerlink" title="获取 Constructor 对象"></a>获取 Constructor 对象</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>{</span><br><span class="line">        <span class="comment">//method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>{</span><br><span class="line">        <span class="comment">//返回单个构造方法对象</span></span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line">        <span class="comment">//获取单个构造方法对象</span></span><br><span class="line">        Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>{</span><br><span class="line">        <span class="comment">//返回单个公共构造方法对象</span></span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line">        <span class="comment">//小括号中,一定要跟构造方法的形参保持一致</span></span><br><span class="line">        <span class="comment">//获取单个公共构造方法对象</span></span><br><span class="line">        Constructor constructor1 = clazz.getConstructor();</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line">        <span class="comment">//这里获取有参构造方法</span></span><br><span class="line">        Constructor constructor2 = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为Student类中,没有只有一个int的构造,所以这里会报错.</span></span><br><span class="line">        Constructor constructor3 = clazz.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(constructor3);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//返回所有构造方法对象的数组</span></span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line">  <span class="comment">//2.获取所有构造方法对象的数组</span></span><br><span class="line">        Constructor[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) {</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//返回所有公共构造方法对象的数组</span></span><br><span class="line">        <span class="comment">//1.获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line">        <span class="comment">//2.获取所有公共构造方法对象的数组</span></span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors) {</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Constructor-创建对象"><a href="#Constructor-创建对象" class="headerlink" title="Constructor 创建对象"></a>Constructor 创建对象</h4><p>那么我们获取到的 Class 对象中的构造方法，不就是为了使用它来创建对象嘛，方法如下：</p><ul><li><code>T newInstance(Object…initargs)</code>：根据指定的构造方法创建对象（T 表示返回值类型，此处为创建对来的对象）</li><li><code>setAccessible(boolean flag)</code>：设置为 true，表示取消访问检查（通过获取私有的构造方法来创建对象，如果用反射强行获取并使用，需要临时取消访问检查）</li></ul><p>也就是说，如果构造方法是 public 的，直接使用 newInstance 即可创建对象；如果构造方法是 private 的，那么需要在创建对象之前临时取消访问检查，也就是 <strong>暴力反射</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student类同上一个示例,这里就不在重复提供了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>{</span><br><span class="line">        <span class="comment">//T newInstance(Object... initargs)：根据指定的构造方法创建对象</span></span><br><span class="line">        <span class="comment">//method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>{</span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取构造方法对象</span></span><br><span class="line">        Constructor constructor = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.利用newInstance创建Student的对象</span></span><br><span class="line">        Student student = (Student) constructor.newInstance(<span class="string">"zhangsan"</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>{</span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取构造方法对象</span></span><br><span class="line">        Constructor constructor = clazz.getConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.利用空参来创建Student的对象</span></span><br><span class="line">        Student student = (Student) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException </span>{</span><br><span class="line">        <span class="comment">//method2的简写格式</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象</span></span><br><span class="line">        Student student = (Student) clazz.newInstance();<span class="comment">//这个方法现在已经过时了,了解一下</span></span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>{</span><br><span class="line">        <span class="comment">//获取一个私有的构造方法并创建对象</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect3.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取一个私有化的构造方法.</span></span><br><span class="line">        Constructor constructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被private修饰的成员,不能直接使用的</span></span><br><span class="line">        <span class="comment">//如果用反射强行获取并使用,需要临时取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.直接创建对象</span></span><br><span class="line">        Student student = (Student) constructor.newInstance(<span class="string">"zhangsan"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(student);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反射获取成员变量"><a href="#反射获取成员变量" class="headerlink" title="反射获取成员变量"></a>反射获取成员变量</h3><ol><li>获取 Class 对象</li><li>获取 Field 对象</li><li>赋值或者取值</li></ol><h4 id="数据准备-2"><a href="#数据准备-2" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String name;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">public</span> String gender;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money = <span class="number">300</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student{"</span> +  </span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +  </span><br><span class="line">                <span class="string">", age="</span> + age +  </span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +  </span><br><span class="line">                <span class="string">", money="</span> + money +  </span><br><span class="line">                <span class="string">'}'</span>;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>{</span><br><span class="line">       <span class="comment">// method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//返回所有公共成员变量对象的数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect4.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取Field对象.</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) {</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//返回所有成员变量对象的数组</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect4.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取所有的Field对象</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) {</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>{</span><br><span class="line">        <span class="comment">//返回单个公共成员变量对象</span></span><br><span class="line">        <span class="comment">//想要获取的成员变量必须是真实存在的</span></span><br><span class="line">        <span class="comment">//且必须是public修饰的.</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect4.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取name这个成员变量</span></span><br><span class="line">        <span class="comment">//Field field = clazz.getField("name");</span></span><br><span class="line">        <span class="comment">//Field field = clazz.getField("name1");</span></span><br><span class="line">        Field field = clazz.getField(<span class="string">"money"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(field);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>{</span><br><span class="line">        <span class="comment">//返回单个成员变量对象</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect4.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取money成员变量</span></span><br><span class="line">        Field field = clazz.getDeclaredField(<span class="string">"money"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(field);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Field对象取值或赋值"><a href="#Field对象取值或赋值" class="headerlink" title="Field对象取值或赋值"></a>Field 对象取值或赋值</h4><p>既然获取到 Field 对象了，那么就赋值或取值吧</p><p>赋值：<code>void set(Object obj, Object value)</code>，给指定对象的成员变量赋值<br>取值：<code>Object get(Object obj)</code>，返回指定对象的 Field 值</p><p>为什么中间需要有一个 Object 类呢？比如遇到如下情形，set 方法怎么知道需要将值赋给谁呢？<br><img data-src="https://s2.loli.net/2022/12/21/M3VYLkhu1PITO5j.png" alt="05-为成员变量赋值.png"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>{  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException </span>{  </span><br><span class="line">        <span class="comment">//返回由该 Field表示的字段在指定对象上的值。  </span></span><br><span class="line">        <span class="comment">//method1();  </span></span><br><span class="line">        <span class="comment">//method2();    }  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException </span>{  </span><br><span class="line">        <span class="comment">//给obj对象的成员变量赋值为value  </span></span><br><span class="line">        <span class="comment">//1.获取class对象  </span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect4.Student"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//2.获取name这个Field对象  </span></span><br><span class="line">        Field field = clazz.getField(<span class="string">"name"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//3.利用set方法进行赋值.  </span></span><br><span class="line">        <span class="comment">//3.1先创建一个Student对象  </span></span><br><span class="line">        Student student = (Student) clazz.newInstance();  </span><br><span class="line">        <span class="comment">//3.2有了对象才可以给指定对象进行赋值  </span></span><br><span class="line">        field.set(student,<span class="string">"zhangsan"</span>);  </span><br><span class="line">  </span><br><span class="line">        System.out.println(student);  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, InstantiationException, IllegalAccessException </span>{  </span><br><span class="line">        <span class="comment">//1.获取class对象  </span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect4.Student"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//2.获取成员变量Field的对象  </span></span><br><span class="line">        Field field = clazz.getDeclaredField(<span class="string">"money"</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//3.取消一下访问检查  </span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//4.调用get方法来获取值  </span></span><br><span class="line">        <span class="comment">//4.1创建一个对象  </span></span><br><span class="line">        Student student = (Student) clazz.newInstance();  </span><br><span class="line">        <span class="comment">//4.2获取指定对象的money的值  </span></span><br><span class="line">        Object o = field.get(student);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//5.打印一下  </span></span><br><span class="line">        System.out.println(o);  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="反射获取成员方法"><a href="#反射获取成员方法" class="headerlink" title="反射获取成员方法"></a>反射获取成员方法</h3><ol><li>获取 Class 对象</li><li>获取 Method 对象</li><li>运行方法</li></ol><ul><li><code>Method[] getMethods()</code>：返回所有公共成员方法对象的数组，包括继承的</li><li><code>Method[] getDeclaredMethods()</code>：返回所有成员方法对象的数组，不包括继承的</li><li>返回单个公共成员方法对象</li><li>返回单个成员方法对象</li></ul><h4 id="数据准备-3"><a href="#数据准备-3" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//私有的，无参无返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>{  </span><br><span class="line">        System.out.println(<span class="string">"私有的show方法，无参无返回值"</span>);  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//公共的，无参无返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span>{  </span><br><span class="line">        System.out.println(<span class="string">"function1方法，无参无返回值"</span>);  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//公共的，有参无返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">(String name)</span> </span>{  </span><br><span class="line">        System.out.println(<span class="string">"function2方法，有参无返回值,参数为"</span> + name);  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//公共的，无参有返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">function3</span><span class="params">()</span> </span>{  </span><br><span class="line">        System.out.println(<span class="string">"function3方法，无参有返回值"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aaa"</span>;  </span><br><span class="line">    }  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//公共的，有参有返回值  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">function4</span><span class="params">(String name)</span> </span>{  </span><br><span class="line">        System.out.println(<span class="string">"function4方法，有参有返回值,参数为"</span> + name);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"aaa"</span>;  </span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>{</span><br><span class="line">        <span class="comment">//method1();</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//method4();</span></span><br><span class="line">        <span class="comment">//method5();</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line">        <span class="comment">//返回所有公共成员方法对象的数组，包括继承的</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect5.Student"</span>);</span><br><span class="line">        <span class="comment">//2.获取成员方法对象</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="comment">//3.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) {</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回所有成员方法对象的数组，不包括继承的</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect5.Student"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取Method对象</span></span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="comment">//3.遍历一下数组</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) {</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>{</span><br><span class="line">        <span class="comment">//返回单个公共成员方法对象</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect5.Student"</span>);</span><br><span class="line">        <span class="comment">//2.获取成员方法function1</span></span><br><span class="line">        Method method1 = clazz.getMethod(<span class="string">"function1"</span>);</span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(method1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>{</span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect5.Student"</span>);</span><br><span class="line">        <span class="comment">//2.获取一个有形参的方法function2</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"function2"</span>, String.class);</span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(method);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>{</span><br><span class="line">        <span class="comment">//返回单个成员方法对象</span></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect5.Student"</span>);</span><br><span class="line">        <span class="comment">//2.获取一个成员方法show</span></span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">"show"</span>);</span><br><span class="line">        <span class="comment">//3.打印一下</span></span><br><span class="line">        System.out.println(method);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="运行成员方法"><a href="#运行成员方法" class="headerlink" title="运行成员方法"></a>运行成员方法</h4><ul><li><code>Object invoke(Object obj, Object… args)</code>：运行方法<ul><li>参数 1：用 obj 对象调用该方法</li><li>参数 2：调用方法的传递的参数（如果没有就不写）</li><li>返回值：方法的返回值（如果没有就不写）</li></ul></li></ul><p>比如说，我们现在想通过反射来获取 Class 中的 function4 方法，并运行它</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException </span>{</span><br><span class="line">    <span class="comment">//Object invoke(Object obj, Object... args)：运行方法</span></span><br><span class="line">    <span class="comment">//参数一：用obj对象调用该方法</span></span><br><span class="line">    <span class="comment">//参数二：调用方法的传递的参数（如果没有就不写）</span></span><br><span class="line">    <span class="comment">//返回值：方法的返回值（如果没有就不写）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"com.itheima.myreflect5.Student"</span>);</span><br><span class="line">        <span class="comment">//2.获取里面的Method对象  function4</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"function4"</span>, String.class);</span><br><span class="line">        <span class="comment">//3.运行function4方法就可以了</span></span><br><span class="line">        <span class="comment">//3.1创建一个Student对象,当做方法的调用者</span></span><br><span class="line">        Student student = (Student) clazz.newInstance();</span><br><span class="line">        <span class="comment">//3.2运行方法</span></span><br><span class="line">        Object result = method.invoke(student, <span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="comment">//4.打印一下返回值</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;反射的概述&quot;&gt;&lt;a href=&quot;#反射的概述&quot; class=&quot;headerlink&quot; title=&quot;反射的概述&quot;&gt;&lt;/a&gt;反射的概述&lt;/h3&gt;&lt;p&gt;反射机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；&lt;/li&gt;
&lt;li&gt;对于任意一个对象，都能够调用它的任意属性和方法；&lt;/li&gt;
&lt;li&gt;这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</summary>
    
    
    
    <category term="Java" scheme="https://coffeelize.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://coffeelize.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>写在博客创建的一周年</title>
    <link href="https://coffeelize.top/posts/cf194633.html"/>
    <id>https://coffeelize.top/posts/cf194633.html</id>
    <published>2022-12-19T13:13:10.000Z</published>
    <updated>2022-12-19T14:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="coffeelize"><a href="#coffeelize" class="headerlink" title="coffeelize"></a>coffeelize</h3><p>这两天收到阿里云域名续费消息，同时也收到了网站 SSL 证书到期的邮件，是的，域名买了一年，到今天刚好一年。</p><span id="more"></span><p>博客在中途更换过一次域名，也就是现在的域名：<code>coffeelize.top</code>。之所以叫 coffeelize，不仅仅是因为 #咖啡日常 #，更多的其实是想强调 <code>lize</code>。<code>lize</code> 在英语单词中通常为动词的后缀，很多情况下 <code>名词 + lize</code> 后就变成了动词，一是想表达：就像喝了一杯咖啡一样，满满的驱动力；二是期望：自己能够像 “coffeee” 那样，能够带给周围人更多的积极向上的 “动力”。</p><p><img data-src="https://s2.loli.net/2022/12/19/x8gyqlSMFsrhIRk.png" alt="01-博客运行时间.png"></p><p><img data-src="https://s2.loli.net/2022/12/19/JUlu2bNvLd6M8Oo.png" alt="02-域名续费消息.png"></p><p><img data-src="https://s2.loli.net/2022/12/19/Zs513UwFVmuAnaf.png" alt="03-证书到期.png"></p><p>去年的这个时候，还在复习着数值分析的期末考试呢😂，搭建这个博客花了我很长时间，记得那个 SSL 总是无法正常连接，导致无法往仓库中推送文件，也算是苦中作乐吧，哈哈</p><p>有了自己的个人博客之后，开始关注更多相关领域的个人博客，学着有模有样的发布笔记、装扮博客、交换友链，开始更加注重消息的来源和质量。自己也喜欢看别人的博客和笔记，有种窥探别人日记本闯入他人领地的感觉，遇到和自己 “技术栈” 差不多的站长，会主动联系，加个好友、交换一下友链或者相互鼓励一下，这种感觉很棒，可能也是我不断更新下去的主要原因吧。</p><p>博客在这一年里也有一点点的收获，下图为必应搜索引擎的数据报告（因为之前更换了一次域名的原因，这里只显示从 6 月份开始到现在的数据）</p><p><img data-src="https://s2.loli.net/2022/12/19/pXoBg9TFJK8xmaC.png" alt="05-必应控制台.png"></p><p>其实我也不在乎这个数据报告，更在乎的是我的🤝朋友们及笔记呀<br><img data-src="https://s2.loli.net/2022/12/19/HyleRzDBEp4ISbc.png" alt="06-朋友们以及笔记.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;coffeelize&quot;&gt;&lt;a href=&quot;#coffeelize&quot; class=&quot;headerlink&quot; title=&quot;coffeelize&quot;&gt;&lt;/a&gt;coffeelize&lt;/h3&gt;&lt;p&gt;这两天收到阿里云域名续费消息，同时也收到了网站 SSL 证书到期的邮件，是的，域名买了一年，到今天刚好一年。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Life" scheme="https://coffeelize.top/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Git 简明教程</title>
    <link href="https://coffeelize.top/posts/6326f1e4.html"/>
    <id>https://coffeelize.top/posts/6326f1e4.html</id>
    <published>2022-12-18T06:42:20.000Z</published>
    <updated>2022-12-19T14:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h3><p>Git 是一个分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java 类、xml 文件、html 页面等），在软件开发过程中被广泛使用</p><span id="more"></span><h3 id="Git-能做什么"><a href="#Git-能做什么" class="headerlink" title="Git 能做什么"></a>Git 能做什么</h3><ul><li>代码回溯：Git 在管理文件过程中会记录日志，方便回退到历史版本</li><li>版本切换：Git 存在分支的概念，一个项目可以有多个分支（版本），可以任意切换</li><li>多人协作：Git 支持多人协作，即一个团队共同开发一个项目，每个团队成员负责一部分代码，通过 Git 就可以管理和协调</li><li>远程备份：Git 通过仓库管理文件，在 Git 中存在远程仓库，如果本地文件丢失还可以从远程仓库获取</li></ul><p>我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有 GitHub、码云、GitLab 等，这里以码云为例进行讲解</p><h3 id="Git-全局设置"><a href="#Git-全局设置" class="headerlink" title="Git 全局设置"></a>Git 全局设置</h3><p>当安装 Git 后首先要做的事情是设置用户名称和 email 地址。这是非常重要的，因为每次 Git 提交都会使用该用户信息。在 Git 命令行中执行下面命令：</p><ul><li>设置用户信息 </li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"coffeelize"</span></span><br><span class="line">git config --global user.email <span class="string">"coffeelize@qq.com"</span></span><br></pre></td></tr></tbody></table></figure><p>注意：<strong>上面设置的 user.name 和 user.email 并不是我们在注册码云账号时使用的用户名和邮箱</strong>，此处可以任意设置</p><ul><li>查看配置信息 </li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/19/CiSLe2VtpFR7zvK.png" alt="01-配置用户名和邮箱.png"></p><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>要使用 Git 对我们的代码进行管理，首先需要获得 Git 仓库，获取 Git 仓库通常有两种方式</p><ul><li>在本地初始化 Git 仓库（不常用）</li><li>从远程仓库克隆（常用）</li></ul><h4 id="在本地初始化-Git-仓库"><a href="#在本地初始化-Git-仓库" class="headerlink" title="在本地初始化 Git 仓库"></a>在本地初始化 Git 仓库</h4><ol><li>在任意目录下创建一个空目录（例如 repo1）作为我们的本地 Git 仓库</li><li>进入这个目录中，点击右键打开 Git bash 窗口</li><li>执行命令 <code>git init</code></li></ol><p>初始化之后，目录中会多一个 <code>.git</code> 隐藏文件夹，命令行后会多出一个 master 分支<br><img data-src="https://s2.loli.net/2022/12/19/Z7mXMf8ovShOWUF.png" alt="02-master主分支.png"></p><p>注意：本地仓库不是从远程仓库克隆下来的，且本地仓库中若已经存放了一些文件，此时再从远程仓库拉去文件的时候可能会报如下所示的错误：fatal: refusing to merge unrelated histories（原因是本地仓库中含有本地仓库中文件的历史记录，远程仓库中包含远程仓库中文件的记录信息，这两者间完全没有联系，此时就需要将两者建立起联系）</p><p><img data-src="https://s2.loli.net/2022/12/19/aw3mrhOHW9vg1Zb.png" alt="016-本地仓库首次连接远程仓库报错.png"></p><p>此时，可以通过如下命令解决</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></tbody></table></figure><h4 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h4><p>可以通过 Git 提供的命令从远程仓库进行克隆，将远程仓库克隆到本地</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远程仓库地址</span><br></pre></td></tr></tbody></table></figure><p>注：第一次克隆远程仓库时，可能需要登录 Git Credential Manage，即登录 Gitee 的账号，登录之后即可正常操作。同时登录之后，也会将一些验证信息保存到电脑当中，之后再次使用就不用再手动登录了</p><p><img data-src="https://s2.loli.net/2022/12/19/jMc9uwJOTRiW17E.png" alt="03-登录Gitee验证.png"></p><h3 id="工作区、暂存区、版本库"><a href="#工作区、暂存区、版本库" class="headerlink" title="工作区、暂存区、版本库"></a>工作区、暂存区、版本库</h3><ul><li><strong>版本库</strong>：前面看到的 <code>.git 隐藏文件夹</code> 就是版本库，版本库中存储了很多配置信息、日志信息和文件版本信息等</li><li><strong>工作区</strong>：包含.git 文件夹的目录就是工作区，也称为工作目录，主要用于存放开发的代码</li><li><strong>暂存区</strong>：.git 文件夹中有很多文件，其中有一个 <code>index 文件</code> 就是暂存区。暂存区是一个临时保存修改文件的地方</li></ul><h3 id="Git-工作区中文件的状态"><a href="#Git-工作区中文件的状态" class="headerlink" title="Git 工作区中文件的状态"></a>Git 工作区中文件的状态</h3><p>Git 工作区中的文件存在两种状态：</p><ul><li>untracked：未跟踪（未被纳入版本控制）</li><li>tracked：已跟踪（被纳入版本控制）<ul><li>Unmodified 未修改状态</li><li> Modified 已修改状态</li><li> Staged 已暂存状态</li></ul></li></ul><h3 id="本地仓库常用操作"><a href="#本地仓库常用操作" class="headerlink" title="本地仓库常用操作"></a>本地仓库常用操作</h3><ul><li>git status：查看文件状态</li><li> git add：将文件的修改加入暂存区</li><li> git reset：将暂存区的文件取消暂存或者是切换到指定版本</li><li> git commit：将暂存区的文件修改提交到版本库</li><li> git log：查看日志</li></ul><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>可以通过 <code>git status</code> 来查看当前状态<br><img data-src="https://s2.loli.net/2022/12/19/aAXWUjsLFzoqeDQ.png" alt="04-status查看状态.png"></p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add fileName</span><br></pre></td></tr></tbody></table></figure><h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p>每次 Git 提交都会产生新的版本号，通过版本号就可以回到历史版本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br><span class="line">git reset --hard 76b00c3fd44c92359d70e02cb4ff35c3acf90b40</span><br></pre></td></tr></tbody></table></figure><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m msg 文件名</span><br><span class="line">git commit -m <span class="string">"提交一个文件"</span> User.java</span><br></pre></td></tr></tbody></table></figure><p>红色字体：未跟踪，也就是还没有纳入 git 的版本管理<br>绿色字体：文件已经放到了缓存区</p><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>git log 命令的作用是查看提交日志；通过 git log 命令查看日志，可以发现每次提交都会产生一个版本号，提交时设置的 message、提交人、邮箱、提交时间等信息都会记录到日志中</p><p><img data-src="https://s2.loli.net/2022/12/19/gKTMRtdwW6nSsvL.png" alt="05-log查看日志.png"></p><h3 id="远程仓库常用命令"><a href="#远程仓库常用命令" class="headerlink" title="远程仓库常用命令"></a>远程仓库常用命令</h3><ul><li>git remote：查看远程仓库</li><li> git remote add：添加远程仓库</li><li> git clone：从远程仓库克隆</li><li> git pull：从远程仓库拉取</li><li> git push：推送到远程仓库</li></ul><h4 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h4><p>origin 表示远程仓库的简称</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br><span class="line">git remote -v</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/19/OQIXkWoCeEtbRj9.png" alt="06-查看远程仓库简称.png"></p><p>说明当前本地的仓库已经和远程的仓库之间建立好了连接了。如果输入以上两个命令没有返回值的话，说明这仅仅只是一个本地仓库</p><h4 id="git-remote-add"><a href="#git-remote-add" class="headerlink" title="git remote add"></a>git remote add</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add 简称 远程仓库地址</span><br></pre></td></tr></tbody></table></figure><p>注意</p><ul><li>一个本地仓库可以关联多个远程仓库</li><li>这个简称我们习惯命名为 origin</li></ul><p>比如我这边初始化了一个本地仓库，然后还有一个远程仓库，想要将这个本地仓库和远程仓库联系起来</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://gitee.com/coffeelize/repo1.git</span><br></pre></td></tr></tbody></table></figure><p>此时再输入命令 <code>git remote -v</code>，即可查看是否已经关联成功</p><h4 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h4><p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远程仓库地址</span><br></pre></td></tr></tbody></table></figure><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>将本地仓库内容推送到远程仓库</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push 远程仓库简称 分支名称</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>先需要将文件提交到本地仓库 (add &amp; commit)，再推送到远程仓库</p><h4 id="切换远程仓库"><a href="#切换远程仓库" class="headerlink" title="切换远程仓库"></a>切换远程仓库</h4><p>如果当前本地仓库需要链接到另一个远程仓库呢，怎么处理？<br>比如说本地仓库当前绑定的是 repo1 仓库，想要将本地仓库绑定到另外一个远程仓库 hellogit。当前如果已经连接到了一个远程仓库，是无法直接通过添加远程仓库 URL 来覆盖掉原来的 URL，如下图所示：</p><p><img data-src="https://s2.loli.net/2022/12/19/eM9OwU4TtP2hbFa.png" alt="017-无法直接覆盖远程连接的URL.png"></p><p>方式一：直接修改远程仓库地址，更换远程仓库地址</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin URL</span><br><span class="line">git remote set-url orgin https://gitee.com/coffeelize/hellogit.git</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>方式二：先先删除当前连接的远程仓库地址，然后在添加</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br><span class="line">git remote add origin url</span><br></pre></td></tr></tbody></table></figure><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>分支是 Git 使用过程中非常重要的概念。使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。</p><p>本地仓库和远程仓库中都有分支，同一个仓库可以有多个分支，各个分支相互独立，互不干扰。通过 git init 命令创建本地仓库时默认会创建一个 master 分支。</p><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><ul><li>git branch：列出所有本地分支</li><li> git branch -r：列出所有远程分支</li><li> git branch -a：列出所有本地分支和远程分支</li></ul><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名称</span><br><span class="line">git branch <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/19/MpQ8A1bmc2wCYov.png" alt="07-创建分支.png"></p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名称</span><br><span class="line">git checkout <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/19/Dmi5soLJWx81thl.png" alt="08-切换分支.png"></p><h4 id="推送至远程仓库分支"><a href="#推送至远程仓库分支" class="headerlink" title="推送至远程仓库分支"></a>推送至远程仓库分支</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push 远程仓库简称 分支名称</span><br><span class="line">//将<span class="built_in">test</span>分支推送到远程仓库</span><br><span class="line">git push origin <span class="built_in">test</span> </span><br></pre></td></tr></tbody></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名称</span><br><span class="line">git merge <span class="built_in">test</span></span><br></pre></td></tr></tbody></table></figure><p>分支合并时需注意合并的方向，是将命令中的分支合并到当前所在的分支</p><p><img data-src="https://s2.loli.net/2022/12/19/7getKomVWPIN3DL.png" alt="09-合并分支.png"></p><p>在合并分支这种大操作下，会进入 vim 模式要求我们写日志，按照 vim 的操作即可</p><p>如果在合并当中遇到文件冲突，比如说主分支对 A 文件进行了修改，测试分支也对 A 文件进行了修改，然后在主分支中合并分支时，报如下错误：Automatic merge failed; fix conflicts and then commit the result.</p><p><img data-src="https://s2.loli.net/2022/12/19/9PgOCTkJ3qyxnr6.png" alt="10-合并分支报错.png"></p><p>此时冲突的文件会自动加入如下内容。<br><img data-src="https://s2.loli.net/2022/12/19/cIbPGwn2ksgdyqh.png" alt="011-合并后的冲突文件.png"></p><p>假如我们是想要保留这两行，那么可以把这些自动生成的符号删除，然后还需要将这个有冲突的文件再 add 和 commit 一下，此时，仍然会有报错：<br>fatal: cannot do a partial commit during a merge.（不能在合并的时候只提交一部分）<br><img data-src="https://s2.loli.net/2022/12/19/U3C4zvuSK1iTYxr.png" alt="012-合并解决冲突文件后再次报错.png"></p><p>这个时候我们需要在 commit 后面添加一个 <code>-i</code> 参数，此时这个冲突被我们手动解决了，然后就可以正常 push 了</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"modify by me"</span> testBranch.txt -i</span><br><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><p>Git 中的标签，指的是某个分支某个特定时间点的状态。通过标签，可以很方便的切换到标记时的状态。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 、v1.2 等）。</p><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></tbody></table></figure><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名</span><br><span class="line">git tag v0.1</span><br></pre></td></tr></tbody></table></figure><h4 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 标签名</span><br><span class="line">git tag -d v0.1</span><br></pre></td></tr></tbody></table></figure><h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/标签名</span><br><span class="line">git push origin :refs/tags/v0.1</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/19/6dlXaVzxyr7GL9O.png" alt="013-删除远程标签.png"></p><h4 id="将标签推送至远程仓库"><a href="#将标签推送至远程仓库" class="headerlink" title="将标签推送至远程仓库"></a>将标签推送至远程仓库</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push 远程仓库简称 标签名</span><br><span class="line">git push origin v0.1</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/19/Ejv9nRudHbUyrFo.png" alt="014-将标签推送至远程仓库.png"></p><h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>检出标签时需要新建一个分支来指向某个标签。会自动将某个 tag 中的内容检出到一个新的分支下面</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 新建的一个分支名 标签名</span><br><span class="line">git checkout -b aNewBranch v0.2</span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/19/dyaphUSAH3scDTP.png" alt="015-检出标签.png"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是-Git&quot;&gt;&lt;a href=&quot;#什么是-Git&quot; class=&quot;headerlink&quot; title=&quot;什么是 Git&quot;&gt;&lt;/a&gt;什么是 Git&lt;/h3&gt;&lt;p&gt;Git 是一个分布式版本控制工具，主要用于管理开发过程中的源代码文件（Java 类、xml 文件、html 页面等），在软件开发过程中被广泛使用&lt;/p&gt;</summary>
    
    
    
    
    <category term="Git" scheme="https://coffeelize.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 简明笔记</title>
    <link href="https://coffeelize.top/posts/44d474d.html"/>
    <id>https://coffeelize.top/posts/44d474d.html</id>
    <published>2022-12-17T13:26:10.000Z</published>
    <updated>2023-05-15T06:29:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Lombok 是一个 Java 类库，提供了一组注解，用于简化 POJO 实体类开发</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="导入坐标"><a href="#导入坐标" class="headerlink" title="导入坐标"></a>导入坐标</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String password;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">    <span class="keyword">private</span> String tel;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用-lombok-注解"><a href="#使用-lombok-注解" class="headerlink" title="使用 lombok 注解"></a>使用 lombok 注解</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String password;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">    <span class="keyword">private</span> String tel;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>@Setter：为模型类的属性提供 setter 方法</li><li> @Getter：为模型类的属性提供 getter 方法</li><li> @ToString：为模型类的属性提供 toString 方法</li><li> @NoArgsConstructor：提供一个无参构造方法</li><li> @AllArgsConstructor：提供全参构造方法</li><li> @EqualsAndHashCode：为模型类的属性提供 equals 和 hashcode 方法</li></ul><h4 id="进一步简化"><a href="#进一步简化" class="headerlink" title="进一步简化"></a>进一步简化</h4><p><code>@Data</code> 注解除了不包含步骤 3 中的 <code>@NoArgsConstructor</code> 及 <code>@AllArgsConstructor</code> 这两个注解之外，包含其余所有注解。因此，以下代码段与步骤 3 下的代码段等效</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>  </span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String password;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">    <span class="keyword">private</span> String tel;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html"></summary>
      
    
    
    
    
    <category term="Java" scheme="https://coffeelize.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Maven 高级简明笔记</title>
    <link href="https://coffeelize.top/posts/2cb3f51.html"/>
    <id>https://coffeelize.top/posts/2cb3f51.html</id>
    <published>2022-12-17T06:08:30.000Z</published>
    <updated>2022-12-23T04:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="分模块开发与设计"><a href="#分模块开发与设计" class="headerlink" title="分模块开发与设计"></a>分模块开发与设计</h3><p>将原始模块按照功能拆分为若干个子模块，方便模块间的相互调用，接口共享</p><span id="more"></span><p><img data-src="https://s2.loli.net/2022/12/20/2KG3AFHn9IkrQ7s.png" alt="01-分模块开发思想.png"></p><p>Intellij 中同时导入多个模块方式如下：<br><img data-src="https://s2.loli.net/2022/12/20/hYWKdaNVUjRFDug.png" alt="02-Intellij同时导入多个模块.png"></p><p>1、项目准备：之前做好的 SSM 整合的项目 maven_02_ssm 进行讲解<br>2、新建一个模块：maven_03_pojo</p><p>1）新建 com.itheima.domain 包<br>2）将 maven_02_ssm 中的 domain 下的 Book 实体类剪切至 maven_03_pojo 下的 domain 包下<br>3）此时 maven_02_ssm 将无法运行，因为缺少了 Book 实体类<br>4）现在要做到是：如何在 maven_02_ssm 中访问 / 加载 maven_03_pojo 下的 Book 实体类呢？</p><p>maven_03_pojo 模块中 pom.xml 的坐标如下</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>那么我们在 maven_02_ssm 中引入上面的坐标</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--依赖domain运行--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>此时就将 maven_03_pojo 模块引入进来了，此时 maven_02_ssm 也没有报错了</p><p>总结：将一个模块中的一部分功能抽取出来单独做一个模块，然后在原来的使用方去引用这个抽取出来的模块，这样就做成了两个模块</p><p>但是此时 02 模块会有问题？为什么呢<br>因为通过坐标导入，会将相应的资源下载到本地仓库，02 模块引入了 03 模块，但是本地仓库里面却找不到 03 的资源。因此，我们还需要将 03 模块 install 到本地仓库中</p><p><img data-src="https://s2.loli.net/2022/12/20/ZKzeAFyfxuqWJD1.png" alt="03-导入坐标之后需要安装到本地仓库.png"></p><p>安装完之后，本地仓库中就可以找到模块 03 的资源了。此时我们在 compile 一下 02 模块，若能够编译成功，说明没有问题了</p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>如果一个模块 A 依赖了模块 B，而 B 模块依赖了其他的东西，那么这个 A 模块可以直接使用这些东西</p><p>直接依赖：在当前项目中通过依赖配置建立的依赖关系<br>简介依赖：被依赖的资源如果依赖其他资源，当前项目简介依赖其他资源</p><h4 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h4><ul><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</li><li>特殊优先：当同级配置类相同资源的不同版本，后配置的覆盖先配置的</li></ul><p><img data-src="https://s2.loli.net/2022/12/20/NS41odfFWlRwQan.png" alt="04-依赖层级关系.png"></p><p>可以通过此处查看项目中的依赖关系<br><img data-src="https://s2.loli.net/2022/12/20/boJTGpKOdmHg3Vw.png" alt="05-Intellij中查看依赖层级关系.png"></p><h4 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h4><p>比如说 02 模块引用了 04 模块，04 模块中引用了几个坐标。现在的需求是，我不想让 02 模块能够加载或引用 04 模块中的坐标，怎么处理呢？</p><p>那么在 04 模块中，对如下这个坐标进行处理</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递性--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>其实这个需要就是想要某个坐标没有传递性</p><h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><p>比如引用了 <code>maven_04_dao</code> 坐标，但是排除这个坐标下的另外两个坐标</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.itheima&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;maven_04_dao&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span><br><span class="line">  &lt;exclusions&gt;</span><br><span class="line"> &lt;exclusion&gt;</span><br><span class="line">   &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line"> &lt;/exclusion&gt;</span><br><span class="line"> &lt;exclusion&gt;</span><br><span class="line">   &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line"> &lt;/exclusion&gt;</span><br><span class="line">  &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>那么可选和排除有什么区别呢：</p><ul><li>用的可选，别人引用了我的坐标，但是不知道我背后引用了哪些坐标；对外隐藏当前所依赖的资源</li><li>用的排除，别人是知道我背后引用了那些坐标的；主动断开依赖的资源，被排除的资源无需指定版本</li></ul><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><img data-src="https://s2.loli.net/2022/12/20/u2RJgQrAbdtn1yO.png" alt="06-聚合的引入.png"></p><p>比如：上面的三个模块都是依赖 pojo 模块的，假如我们更新了 pojo 模块，上面三个模块会及时更新吗？如果 pojo 因为更新出现了问题，上面三个模块能够及时发现吗？</p><p>聚合：将多个模块组织成一个整理，同时进行项目构建的过程称为聚合（其实有点像事务的概念）<br>聚合工程：通常是一个不具有业务功能的 “空” 工程（仅有一个 pom 文件）<br>作用：使用聚合工程可以将多个模块编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建；当工程中某个模块发生更新时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题</p><p>1）创建新 Maven 模块<br>2）聚合工程的特点：在 pom.xml 中，将打包方式设置为 pom</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3）设置管理模块的模块名称</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置管理模块名称</span></span><br><span class="line"><span class="comment">..表示当前文件pom.xml文件的上一级文件</span></span><br><span class="line"><span class="comment">--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="https://s2.loli.net/2022/12/20/W4X3NPlEJMkL1qb.png" alt="07-聚合-引入子模块.png"></p><p><img data-src="https://s2.loli.net/2022/12/20/U8B1hmP9NRurxy2.png" alt="08-聚合后各层级的关系.png"></p><p>4）进行同步编译 compile</p><p><img data-src="https://s2.loli.net/2022/12/20/4WN2ZoTL8AxvcaY.png" alt="09-聚合后进行同步编译.png"></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>概念：继承描述的是两个工程间的关系，与 Java 中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</p><p>作用：简化配置；减少版本冲突</p><p>1）继承关系在子类中描述</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置当前工程继承自parent工程--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>此时，就可以继承父工程中依赖的坐标了</p><p>2）父工程中的坐标都必须要被所有子工程继承吗？不一定<br>可以在父工程 pom 文件中通过 <code>dependencyManagement</code> 来指定这是一个可选的坐标</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>${junit.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>如果子工程中想要引用的话就在 pom 中加上相应的坐标，但是注意不要加版本号，因为他会自动继承父类中坐标的版本号；而对于其他子工程就不会自动继承引用这个坐标</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;junit&lt;/groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;junit&lt;/artifactId&gt;  </span><br><span class="line">  &lt;scope&gt;test&lt;/scope&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>3）子工程继承父工程中的坐标，只要父工程中坐标的版本号一改，所有子工程中对应的版本号都会改</p><p>聚合与继承的区别</p><ul><li>作用<ul><li>聚合用于快速构建项目</li><li>继承用于快速配置</li></ul></li><li>相同点<ul><li>聚合与继承的 pom.xml 文件打包方式均为 pom，可以将两种关系制作到同一个 pom 文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul></li><li>不同点<ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><img data-src="https://s2.loli.net/2022/12/20/7U4sAGSDOdz3f9e.png" alt="10-属性问题的引入.png"></p><p>1）定义属性</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义属性，标签名可以自定义--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2）在定义坐标时，可以直接使用变量</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>${spring.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>${spring.version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3）这样就好了呀，以后可以直接从这儿就可以看到各种坐标的版本</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义属性--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--&lt;jdbc.url&gt;jdbc:mysql://127.0.0.1:3306/ssm_db&lt;/jdbc.url&gt;--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>比如如下为某一工程 pom.xml 中的坐标，其中的 version 有什么用呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.itheima&lt;/groupId&gt;  </span><br><span class="line">&lt;artifactId&gt;maven_02_ssm&lt;/artifactId&gt;  </span><br><span class="line">&lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;  </span><br><span class="line">&lt;packaging&gt;war&lt;/packaging&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>工程版本<ul><li> SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li> RELESE（发布版本）<ul><li>项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构建文件时稳定的，即便进行功能的后续开发，也不会改变当前发布版本的内容，这种版本称为发布版本</li></ul></li></ul></li><li>发布版本<ul><li> alpha 版</li><li> beta 版</li><li>纯数字版</li></ul></li></ul><h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p><img data-src="https://s2.loli.net/2022/12/20/AJfgMke7ODpBI8r.png" alt="011-多环境配置.png"></p><p>maven 提供配置多种环境的设定，帮助开发者使用过程中快速切换环境</p><p>1）在父工程 pom.xml 中</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置多环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--设定是否为默认启动环境--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2）对工程进行 install，然后可以查看项目构建好的 war 包，双击 war 包，进入 WEB-INF 文件夹 ⇒ classes 文件夹 ⇒ jdbc.properties 文件，查看配置是否生效</p><p>如果要更换环境，可以将设置默认启动环境的那几行代码切换一下位置，比如切换到测试环境中，那么 install 后，默认就是测试环境的配置了</p><p>或者可以不用挪动那几行代码，直接使用 Maven 指令来表明我们将使用 <code>env_dep</code> 环境来进行 install，如下图所示<br><img data-src="https://s2.loli.net/2022/12/20/iYJEPMRwrdWb1jV.png" alt="012-Maven指令处理多环境.png"></p><p><img data-src="https://s2.loli.net/2022/12/20/fISheL961B4DZxt.png" alt="013-Maven指令处理多环境-2.png"></p><h4 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h4><p>跳过测试：跳过所有测试<br><img data-src="https://s2.loli.net/2022/12/20/RS4pDOViCos8awT.png" alt="014-跳过测试.png"><br>跳过测试：指定跳过某些内容</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除掉不参与测试的内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/BookServiceTest.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;分模块开发与设计&quot;&gt;&lt;a href=&quot;#分模块开发与设计&quot; class=&quot;headerlink&quot; title=&quot;分模块开发与设计&quot;&gt;&lt;/a&gt;分模块开发与设计&lt;/h3&gt;&lt;p&gt;将原始模块按照功能拆分为若干个子模块，方便模块间的相互调用，接口共享&lt;/p&gt;</summary>
    
    
    
    
    <category term="Maven" scheme="https://coffeelize.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Linux 防火墙设置</title>
    <link href="https://coffeelize.top/posts/c8073837.html"/>
    <id>https://coffeelize.top/posts/c8073837.html</id>
    <published>2022-12-17T04:30:30.000Z</published>
    <updated>2022-12-19T14:31:39.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><span id="more"></span><table><thead><tr><th>操作</th><th>指令</th><th>备注</th></tr></thead><tbody><tr><td>查看防火墙状态</td><td> systemctl status firewalld / firewall-cmd –state</td><td></td></tr><tr><td> 暂时关闭防火墙</td><td> systemctl stop firewalld</td><td></td></tr><tr><td> 永久关闭防火墙 (禁用开机自启)</td><td>systemctl disable firewalld</td><td> 下次启动才生效</td></tr><tr><td>暂时开启防火墙</td><td> systemctl start firewalld</td><td></td></tr><tr><td> 永久开启防火墙 (启用开机自启)</td><td>systemctl enable firewalld</td><td> 下次启动才生效</td></tr><tr><td>开放指定端口</td><td> firewall-cmd –zone=public –add-port=8080/tcp –permanent</td><td> 需要重新加载生效</td></tr><tr><td>关闭指定端口</td><td> firewall-cmd –zone=public –remove-port=8080/tcp –permanent</td><td> 需要重新加载生效</td></tr><tr><td>立即生效 (重新加载)</td><td>firewall-cmd –reload</td><td></td></tr><tr><td> 查看开放端口</td><td> firewall-cmd –zone=public –list-ports</td><td></td></tr></tbody></table><p>注意：为了保证系统安全，不建议关闭服务器的防火墙；可以开放指定端口</p><p>比如说启用 Linux 的 Tomcat 服务，需要开启 8080 端口，</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure><p>然后就可以通过 ip:8080 来访问了 Linux 中的 Tomcat 了</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.119.128:8080</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;防火墙设置&quot;&gt;&lt;a href=&quot;#防火墙设置&quot; class=&quot;headerlink&quot; title=&quot;防火墙设置&quot;&gt;&lt;/a&gt;防火墙设置&lt;/h3&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://coffeelize.top/tags/Linux/"/>
    
  </entry>
  
</feed>
